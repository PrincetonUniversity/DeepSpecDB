
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle
\usepackage{txfonts}
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
%% http://ctan.org/pkg/subcaption
\usepackage{uri}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{semantic}
\usepackage{graphicx}
\usepackage{cases}
\usepackage{hyperref}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage{parcolumns}
\usepackage{iris}
%\usepackage{lstlangcoq}
\usepackage[edges]{forest}
\renewcommand{\lstlistingname}{Figure}

\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000

\lstset{language=C,basicstyle=\ttfamily,
	xleftmargin=\dimexpr\fboxsep-\fboxrule,
	mathescape=true,columns=fullflexible}

\newcommand{\TODO}[1]{\textbf{\textcolor{red}{[ TODO: #1]}}}
%\newcommand{\boxdotright}{\!\mathrel\boxdot\joinrel\rightarrow\!}
\newcommand{\islock}{\boxdotright}
\newcommand{\lockvar}{\islock}
\newcommand{\isaex}{\!\mathrel\odot\joinrel\rightarrow\!}
\newcommand{\xisaex}[1]{\!\mathrel\odot\joinrel\xrightarrow{#1}\!}
%% \newcommand{\ifthenelse}[3]{\text{if }#1\text{ then }#2\text{ else }#3}
\newcommand{\emp}{\mathsf{emp}}

\newcommand\dboxed[1]{\dbox{\ensuremath{#1}}}
\newcommand{\master}[2]{\ensuremath{\mathrm{Master}_{#1}(#2)}}
\newcommand{\snap}[1]{\ensuremath{\mathrm{Snapshot}(#1)}}
\newcommand{\ghost}[2]{\ensuremath{\dboxed{#1}^{#2}}}
\newcommand{\us}{$\mu$s}
\newcommand{\gnamety}{\ensuremath{\mathsf{gname}}}
\newcommand{\treerep}{\ensuremath{\mathsf{Node}}}
\newcommand{\nodeboxrep}{\ensuremath{\mathsf{Node\_ref}}}
\newcommand{\lockinv}{\ensuremath{\mathsf{lock\_inv}}}
\newcommand{\infp}{\ensuremath{\mathsf{InFP}}}

\newcommand{\myhalf}[2]{\ensuremath{\mathsf{my\_half}_{#1}(#2)}}
\newcommand{\publichalf}[1]{\ensuremath{\mathsf{public\_half}(#1)}}

% comments from authors 
\newcommand{\than}[1]{\textbf{\textcolor{blue}{[Than: #1]}}}
\newcommand{\lb}[1]{\textbf{\textcolor{red}{[Lennart: #1]}}}
\newcommand{\wm}[1]{\textbf{\textcolor{violet}{[Willam: #1]}}}
\newcommand{\ignore}[1]{}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{myStyle}{
	backgroundcolor=\color{white},   
	commentstyle=\color{codegreen},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	keepspaces=true,                 
	numbers=left,       
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=1,
}

\title{Verifying Concurrent Search Structure Templates for C Programs using VST} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Duc Than Nguyen}{University of Illinois at Chicago, USA \and \url{http://www.myhomepage.edu} }{johnqpublic@dummyuni.org}{https://orcid.org/0000-0002-1825-0097}{(Optional) author-specific funding acknowledgements}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{William Mansky}{University of Illinois at Chicago, USA}{joanrpublic@dummycollege.org}{[orcid]}{[funding]}

\authorrunning{Duc Than Nguyen and William Mansky} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Duc Than Nguyen and William Mansky} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid one}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{concurrent separation logic, fine-grained locking, logical atomicity,
	Verified Software Toolchain, Iris} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Concurrent search structure templates are a technique for separating the verification of a concurrent data structure into concurrency-control and data-structure components, which can then be modularly combined with no additional proof effort. In this paper, we implement the template approach in the Verified Software Toolchain, and use it to prove correctness of C implementations of concurrent data structures. %say more
\end{abstract}

\section{Introduction}
\label{sec:introduction}
Krishna et al. proposed concurrent search structure templates~\cite{templates} as a method for separating the proof of correctness of a concurrent access method (e.g. optimistic concurrency, hand-over-hand locking, forwarding via internal links) from the proof of correctness of the underlying data structure (e.g. linked list, hashtable, B-tree). The concurrency ``templates'' are verified parametrically over data structure operations, and the data structure operations are verified without any reference to concurrency. In theory, this could allow us to prove the correctness of $n$ (single-threaded) data structure implementations and $m$ concurrency patterns, and immediately obtain $n \times m$ verified concurrent data structures. In practice, the story is more complicated: certain patterns work only for specific data structures or require the data structures to store extra information, while some internal data structure operations may not fit the template model. 

In this paper, we apply the template approach to concurrent data structure implementations in C. We verify them using the Verified Software Toolchain (VST)~\cite{plfcc}, and report on its effectiveness and the challenges we encountered. The template approach depends crucially on the idea of \emph{logically atomic specifications} introduced in TaDA~\cite{tada} and further developed in Iris~\cite{iris}. Our proofs make use of recent work that has integrated Iris-style logical atomicity into VST~\cite{iris-vst-arxiv}.

Our specific contributions are:
\begin{itemize}
\item To the best of our knowledge, this is the first mechanized verification of a template approach to concurrent data structure implementations in a real programming language.
\item 
\end{itemize}


\section{Background}
\subsection{Concurrent Search Structure Templates}
\wm{This is probably more background than we need on search structures.}
A search structure is a data structure designed to efficiently store and retrieve data based on specific search criteria. These structures organize data to enable quick and efficient search, insertion, deletion, and traversal operations. Concurrent search structures, on the other hand, are data structures accessible and modifiable by multiple threads or processes concurrently. However, designing concurrent search structures presents significant challenges, including ensuring correctness and consistency under concurrent access, achieving scalability by minimizing contention and maximizing parallelism, and maintaining performance and efficiency while managing synchronization and memory, including cache behavior. \wm{cite Masstree?} Additionally, these structures must ensure compatibility with diverse hardware and software platforms.

The complex interplay between concurrency and shared memory in concurrent search structures makes formal verification a challenging task. Modularity is crucial in simplifying formal proofs for concurrent search structures, as it is for designing and maintaining large systems. By decomposing complex systems into smaller, more manageable components, modularity facilitates the separation of concerns and minimizes interactions between different parts of the system, reducing the complexity of formal proofs. Moreover, modularity permits the reuse of verified components, further simplifying the verification process. Lock-free hash tables, concurrent tries, and B-trees are frequently used concurrent search structures. These structures allow developers to create efficient, scalable systems while ensuring thread safety.

\than{Need to say the connection to template algorithms here.} 

\wm{point 1 - explain the top-level goal and approach of templates, how it relates to modularity}

\wm{point 2 - lay out the template approach, what a template is, what a data structure is, how their code and their specifications interface}

\subsection{Iris and VST}


\section{Search Structure Templates in VST}

\subsection{Search Structure Templates}
The C implementation of a node in our template style is:
\begin{lstlisting}[language = C, backgroundcolor=\color{white}, basicstyle=\ttfamily\footnotesize]
typedef struct node_t {node *t; lock_t *lock;} node_t;
\end{lstlisting}
\than{I changed \lstinline{tree_t} into \lstinline{node_t}, and \lstinline{tree} into \lstinline{node}, since concurrent search structure will not depend on particular data structures.} 

Each node of type \lstinline{node_t} has a \lstinline{lock} field that protects the node and a \lstinline{t} field that points to a \lstinline{node} struct. Depending on the data structure, the \lstinline{t} field can have different interpretations. In a binary search tree, if the \lstinline{t} field is \lstinline{NULL}, it indicates a leaf node with no key or value; otherwise, it points to a \lstinline{node} struct containing the node's key, value, and child pointers. 
\begin{lstlisting}[language = C, backgroundcolor=\color{white}, basicstyle=\ttfamily\footnotesize]
typedef struct node {int key; void *value; struct node_t *left, *right;} node;
\end{lstlisting}

For a linked list, a \lstinline{t} field with \lstinline{NULL} represents the last node in the list, while a non-null \lstinline{t} field points to a \lstinline{node} struct holding the node's key, value, and a pointer to the next item in the list. 

\begin{lstlisting}[language = C, backgroundcolor=\color{white}, basicstyle=\ttfamily\footnotesize]
typedef struct node {int key; void *value; struct node_t *next;} node;
\end{lstlisting}

%For the purpose of reasoning about lock-coupling style (also known as hand-over-hand locking), we specifically consider traversing the tree using this locking method. To accomplish this, we must maintain at least one lock during traversal between nodes. This requires obtaining the lock for the next node before releasing the lock for the current node. Therefore, we utilize the \lstinline{pn} struct containing two \lstinline{node_t} type nodes: the \lstinline{p} field representing the current node, and the \lstinline{n} field denoting the next node.

\subsubsection{Lock-coupling Template}
The lock-coupling template employs the hand-over-hand locking scheme to prevent interference from other threads during traversal. Each thread continuously maintains at least one lock during traversal between nodes, ensuring that other threads cannot interfere with the traversal or invalidate the ongoing search.

Figure \ref{traverse_lock} shows the \lstinline{traverse} function as presented by Krishna et al. (Figure \ref{traverse_lock_a}) and the corresponding C implementation (Figure \ref{traverse_lock_b}). The C implementation uses a struct
\begin{lstlisting}[language = C, backgroundcolor=\color{white}, basicstyle=\ttfamily\footnotesize]
typedef struct pn {struct node_t *p; struct node_t *n;} pn;
\end{lstlisting}
to mimic the pair of nodes \lstinline{(p, n)} returned by the functional implementation, where \lstinline{n} is the current node and \lstinline{p} is its parent. The algorithm assumes that certain helper functions must be provided by the implementation that satisfy certain criteria. One such function, namely \lstinline{findNext}, is utilized by the algorithm to determine the next node $\texttt{n'}$ to be visited based on the current node $\texttt{n}$ and the key $\texttt{k}$. In the functional version, \lstinline{findNext} returns an \lstinline{option node}; in C, it instead returns a boolean and, if a next node is found, modifies \lstinline{pn->n}.

To ensure thread safety, it is essential to acquire and release locks in a specific order during traversal. The lock-coupling scheme achieves this by requiring threads to acquire locks in increasing order of node addresses. The thread then releases the lock for the previous node before acquiring the lock for the next node in the traversal sequence. This guarantees that the locks are acquired and released in the same order across all threads and prevents deadlocks from occurring.

\begin{figure}[ht]
	\begin{subfigure}[t]{0.45\textwidth}
		\lstinputlisting[language=caml, style=myStyle]{lock_traverse.ml} 
		\caption{The \lstinline{traverse} method of the lock-coupling template algorithm written in an ML-like language \cite{krishna2019compositional}} 
			%\wm{Shouldn't it be lock and then unlock?}} \than{I copied exactly the same from thesis of Krishna. However, in the their of proofs, they had lock before unlock like you said. Do we need to changed to fit with our context and their code?} 
		\label{traverse_lock_a}	
	\end{subfigure}\qquad
	\begin{subfigure}[t]{0.48\textwidth}
		\lstinputlisting[language=C, style=myStyle]{lock_traverse.c} 
		\caption{The \lstinline{traverse} method of the lock-coupling template algorithm written in C}
		\label{traverse_lock_b}
	\end{subfigure}
	\caption{The \lstinline{traverse} method of the lock-coupling template algorithms}
	\label{traverse_lock}
\end{figure}

To implement the template methodology for concurrent data structure implementations in C, we have implemented the \lstinline{traverse} function in C, as depicted in Figure \ref{traverse_lock_a}.  Our version of the \lstinline{traverse} function closely resembles the one written in an ML-like language, as it relies on a helper function called \lstinline{findNext}. The purpose of \lstinline{findNext} is to determine the next node to be visited during the traversal. In our implementation, the \lstinline{traverse} function stops when it reaches the base case, which occurs when the current node is \lstinline{NULL}. Alternatively, it terminates if \lstinline{findNext} fails to find a next node that includes the key value $\texttt{k}$ in the set of key values. The \lstinline{traverse} function returns a Boolean value indicating whether it has successfully found the next node during traversal. If it fails to do so, it returns false, which other functions can use to make decisions. For instance, in a binary search tree, a node with a value of 42 would have a left child with a set of key values consisting of values less than 42 and a right child with one greater than 42. If we want to insert a new node with the target key $\texttt{k}$ into the tree, we can use the \lstinline{traverse} function to traverse the tree. When \lstinline{traverse} fails to find the next node (either to the left or right), it implies that it has reached a node with a target key $\texttt{k}$ that equals the node's value. 

When \lstinline{findNext} arrives at a new node, it acquires a lock for that node, as is the nature of hand-over-hand locking. It then releases the lock for the current node, ensuring that the link between the two nodes is not removed or rearranged while traversing it. To utilize the template methodology for concurrent data structure implementations, it is crucial to keep track of the locks acquired for each node during the traversal. 

\subsubsection{Give-Up Template}
The give-up template is an algorithm for implementing concurrent search in a tree data structure. Unlike the lock-coupling template, which maintains locks during traversal between nodes, the give-up template takes an \emph{optimistic concurrency control} approach \lb{c.f. RCU}, only acquiring locks when loading or storing to a node. This reduces the amount of time that locks are held and makes the algorithm more scalable in highly-contended scenarios. Each node has a range field that serves as a reference point for threads to determine if they are still on the correct path. If a thread finds that it has deviated from the expected path, it abandons the node by releasing the lock and returns to the root node to start again. This behavior aligns with the give-up template algorithm's approach, in which threads terminate their search upon encountering obstacles or deviating from the expected path.

\begin{figure}[!ht]
	\begin{subfigure}[t]{0.45\textwidth}
		\lstinputlisting[language=caml, style=myStyle]{giveup_traverse.ml} 
		\caption{The \lstinline{traverse} method of the give-up template algorithm written in ML-like language}
		\label{traverse_giveup_a}	
	\end{subfigure}\qquad
	\begin{subfigure}[t]{0.48\textwidth}
		\lstinputlisting[language=C, style=myStyle]{giveup_traverse.c} 
		\caption{The \lstinline{traverse} method of the give-up template algorithm written in C}
		\label{traverse_giveup_b}
	\end{subfigure}
	\caption{The \lstinline{traverse} method of the give-up template algorithms}
	\label{traverse_giveup}
\end{figure}

Figure \ref{traverse_giveup_a} depicts the give-up template algorithm as originally presented. The give-up template algorithm uses a helper function called \lstinline{inRange}, in addition to the \lstinline{findNext} function discussed earlier in the lock-coupling section. 
\than{Could you write more things here to explain why we need inRange.}
The purpose of the \lstinline{inRange} function is to determine whether the key value $\texttt{k}$ falls within the range of node $\texttt{n}$. If the key value is outside the node's range, the search is terminated, and the thread is restarted. To implement the template algorithm, it is crucial to keep track of the lower and upper bounds of the keys present in the subtree rooted at the current node. Therefore, we have incorporated two new fields, \lstinline{min} and \lstinline{max}, into each node of type \lstinline{node_t} in our C implementation. These fields store the lower and upper bounds of the keys, respectively. In the context of binary search trees, each node is labeled with a range that is associated with a lower and upper bound on the keys. This begins with $(\texttt{min}, \texttt{max}) = (-\infty, +\infty)$ at the root node and is propagated to the empty leaf nodes. If the root node (which also serves as the parent of a node) has a key of $42$, the left leaf node's range would be $(\texttt{min}, \texttt{max}) = (-\infty, 42)$, and the right leaf node's range would be $(\texttt{min}, \texttt{max}) = (42, +\infty)$.

%\wm{Describe why we need extra pieces in the struct, and how this relates to the other version.}
\begin{lstlisting}[language = C, backgroundcolor=\color{white}, basicstyle=\ttfamily\footnotesize]
	typedef struct node_t {node *t; lock_t *lock; int min; int max;} node_t;
\end{lstlisting}

%% C implementation 


When a thread arrives at a node in search of the key $\texttt{k}$, it checks whether $\texttt{k}$ falls within the range of that node. If $\texttt{k}$ falls within the range, the thread continues by calling \lstinline{findNext} to find the new node. If $\texttt{k}$ does not fall within the range, the thread releases the lock and returns to the root node by assigning the pointer of the root to the pointer of the current node (lines 21-22 in Figure \ref{traverse_giveup_a}).

\subsection{Proofs of Templates} \than{Can someone suggest another title?}

In this section, we verify \lstinline{traverse} for both lock-coupling and give-up templates.  

For many concurrent data structures, the ideal correctness condition requires that the data structure behaves identically to a sequential implementation, even when accessed concurrently by multiple threads. The concurrent behavior of search structures is specified using \emph{atomic triples}~\cite{tada}. These take the form of $\forall a.\ \left\langle \texttt{P}_l\ |\ \texttt{P}_p(a) \right\rangle\ \texttt{c}\ \left\langle \texttt{Q}_l\ |\ \texttt{Q}_p(a)\right\rangle$, where $\texttt{P}_l$ and $\texttt{Q}_l$ are \emph{local} preconditions and postconditions, akin to a standard Hoare triple, while $\texttt{P}_p$ and $\texttt{Q}_p$ are \emph{public} preconditions and postconditions, parameterized by an abstract value $a$ of the shared data structure. This triple suggests that if $\texttt{P}_l$ holds true before a call and $\texttt{P}_p$ is true for some value of $a$ in a shared state (e.g. a global invariant), then $\texttt{P}_p$ will continue to be true for some (possibly different) value of $a$ until the \emph{linearization point} of $\texttt{c}$, at which point $\texttt{Q}_p$ will become true atomically for the same value $a$ (and $\texttt{Q}_l$ will be true after $\texttt{c}$ ends). For instance, the specification
$\forall s.\ \left\langle \texttt{is\_stack}_g\ p\ |\ \texttt{stack}_g\ s\right\rangle\ \texttt{push}(v)\ \left\langle \texttt{is\_stack}_g\ p\ |\ \texttt{stack}_g\ (v::s)\right\rangle$
expresses the fact that the push operation of a concurrent stack correctly implements the behavior of a sequential push, atomically transitioning from particular stack $s$ to $v::s$ at some point during its execution. The stack itself is treated as a publicly owned resource, and can only be accessed and modified atomically by threads holding the \texttt{is\_stack} assertion.

To demonstrate the proof of an implementation that meets the atomic specification, let's take the example of the stack specification mentioned above. This specification assert that the implementation \texttt{push} appears to execute atomically, accessing and updating the state of the data structure without exposing any intermediate states. The local preconditions and postconditions, \texttt{is\_stack}, contain the points-to and lock-invariant assertions necessary for a thread, while the public preconditions and postconditions, \texttt{stack}, involve the ghost state that defines the overall state of the stack. Ghost state is a type of program state that aids in the verification process without affecting the program's runtime behavior, and by referring to an arbitrary ghost state identifier $g$ (which we will generally omit), it is possible to connect local and public conditions. To show that the implementation of \texttt{push}(v) satisfies these atomic specifications, two things must be demonstrated. Firstly, the implementation can execute safely without owning any piece of public assertion $\texttt{stack}$, only accessing it automatically and restoring it up until the linearization point. Secondly, at some linearization point, the implementation transforms the current stack $s$ into $v::s$ atomically, which satisfies the public postcondition $\texttt{stack}(v::s)$. 

\subsubsection{Lock-coupling Template}
\label{traverse_proof_lock}
Proceeding with the proofs, we establish the following specification for the \lstinline{traverse} function in the lock-coupling template:
%\than{Try to avoid using specific name of $\mathrm{tree\_rep}$ for public condition, I suggested to use $\mathrm{Node}$ for generic purpose.} 
\begin{mathpar}
	{\color{blue} {\forall \texttt{t}.\ \left\langle \nodeboxrep \texttt{(pn->n)} 
	\ast \texttt{R(pn->n)} \ | \ \treerep\ \texttt{t} \right\rangle}}\\ 
	\texttt{traverse(pn, k)} \\ 
	\color{blue} {\langle \ \texttt{res} \ \texttt{n'}. \ (\texttt{res} \leftrightarrow (\texttt{pn->n'->t} = \texttt{NULL})) \ast \nodeboxrep \texttt{(pn->n')} \ast }
	\\ 
	\color{blue} {\texttt{R(pn->n')} \ast (\texttt{k} \in \texttt{range(n')})
	\   |\ \treerep\ \texttt{t} \rangle}
\end{mathpar}


%\than{Actually, $\nodeboxrep \texttt{(pn->n)}$ and $\texttt{data\_at  n pn} \ast \texttt{my\_half g\_root} (-\inf, +\inf)$ is equivalent to $\texttt{tree\_rep}$. But now we can ignore the information of $\texttt{my\_half}$.  }

The specifics of $\nodeboxrep$ and $\treerep$ may vary across implementations, but fundamentally, $\nodeboxrep$ encompasses resources associated with each client thread, while $\treerep$ serves as an abstract representation containing ghost state that links the data structure's concrete state to its abstract equivalent, treated as an atomically accessed shared resource. In particular, $\nodeboxrep(\texttt{pn->n})$ acts as a pointer to both the node's lock and lock-invariant assertions, representing a protected resource through an arbitrary separation logic predicate. Acquiring this lock allows a thread to access additional elements within the data structure.

As previously mentioned, the \lstinline{pn} struct includes two nodes of type \lstinline{node_t}: the $\texttt{p}$ field, signifying the parent node, and the $\texttt{n}$ field, representing the current node. We use the assertion $\ell \lockvar \texttt{R}$ to associate a resource invariant \texttt{R} with a lock location $\ell$. Thus, formally, we can express $\nodeboxrep \texttt{(pn->n)} = \texttt{pn->n->lock} \lockvar \texttt{R(pn->n)}$.

Keep in mind that in the lock-coupling style, each thread consistently retains at least one lock while traversing between nodes, ensuring that other threads cannot interfere with the traversal or invalidate the ongoing search. Consequently, before calling the \texttt{traverse} function, the thread must acquire a lock for the current node $\texttt{pn->n}$ and obtain the resource safeguarded by the lock. This resource, represented as $\texttt{R(pn->n)}$, is parameterized by a node pointer $\texttt{pn->n}$ and describes the node's concrete information.

As mentioned earlier, we can define a piece of ghost state, $\texttt{ghost\_node t}$, connecting the node in memory to the public abstract state of the data structure. Specifically, we can have one half of the ghost state contained in the resource $\texttt{R(pn->n)}$, and the other half in the abstract state $\texttt{Node t}$. When proving the atomic triple above, at the linearization point where we access $\texttt{Node}$, we combine both halves of the ghost state, update them to reflect the new state of the concrete data structure, and then fulfill the atomic postcondition with one half of the ghost state, returning the other half to the lock invariant.

In the specification, the local pre-condition includes both the representation of the node $\nodeboxrep(\texttt{pn->n})$ and the resource $\texttt{R(pn->n)}$. When the \texttt{traverse} function operates on the entire search structure, it generates a subsequent node, \texttt{n'}, such that the key \texttt{k} falls within the range of node \texttt{n'}. The local post-condition is expected to encompass the representation of the new node $\nodeboxrep(\texttt{pn->n'})$, the resource $\texttt{R(pn->n)}$, and a Boolean variable, \texttt{res}, which indicates whether \texttt{pn->n'->t} is \texttt{NULL} or not. The key to verifying the \texttt{traverse} function is identifying the loop invariant for the top-level loop. We define the loop invariant for the lock-coupling style \texttt{traverse} function as follows:

\begin{align*} &\texttt{traverse\_inv(pn)} \triangleq\ \exists \texttt{n'}.\ (\texttt{k} \in \texttt{range})\land \nodeboxrep(\texttt{pn->n'})  \ast  \texttt{R(pn->n')}   
\end{align*}
The loop invariant mentioned above include specific existential variables (such as $\texttt{n'}$) that define the state of each iteration throughout the loop. The \lstinline{traverse} function stops when it reaches the base case, which occurs when the current node is \lstinline{NULL} (see line 6 in Figure \ref{traverse_lock_b}). At this point, the specification indicates that we have $\texttt{k} \in \texttt{range(n')} \ast \texttt{pn->n'->t} = \texttt{NULL}$, enabling us to prove the post-condition. On the other hand, the function terminates if \lstinline{findNext} is unable to locate a subsequent node with the key value  $\texttt{k}$ within its set of key values (refer to line 11 in Figure \ref{traverse_lock_b}). In this case, the specification clarifies that $\texttt{k} \in \texttt{range(n')} \ast \texttt{pn->n'->t} \neq \texttt{NULL}$ which also enables us to prove the post-condition. 

%The loop invariants mentioned above include specific existential variables (such as $\texttt{n'}$) that define the state of each iteration throughout the loop.
% CHANGE pn-> p to pn->n 

The proof begins with $\nodeboxrep \texttt{(pn->n)}$, which comprises a lock invariant $\texttt{pn->n->lock} \lockvar \texttt{R(pn->n)}$, and a resource $\texttt{R(pn->n)}$ acquired before invoking the \lstinline{traverse} function. After \lstinline{findNext} successfully detects the next node (for example, \texttt{n'}) to visit, we acquire the lock of node \texttt{n'} (see line 14 in Figure \ref{traverse_lock_b}). It means we can get the resource $\texttt{R(pn->n')}$ from $\texttt{pn->n'->lock} \lockvar \texttt{R(pn->n')}$. Subsequently, we release the lock of the current node \texttt{p}. It is important to note that \texttt{p} point to the same memory address as \texttt{n} (line 4 in Figure \ref{traverse_lock_b}). By acquiring the lock for the next node \texttt{n'} before releasing the lock for the current node \texttt{p}, we ensure that the connection between the two nodes remains intact and unaltered while we traverse it (hand-over-hand locking). 
The proof concludes by verifying that the \lstinline{traverse} function fulfills the post-condition of the specification mentioned earlier.

%\than{FIX ME: These things above didn't represent hand-over-hand locking instance, since I tried to avoid talking about lock invariant.}
\than{I feel somewhat perplexed while attempting to articulate the situation mentioned above. Can someone help me fix or explain it more?}


\subsubsection{Give-up Template}
Moving forward with the proofs, we define the following specification for the traverse function within the give-up template:

\begin{mathpar}
	{\color{blue}{\forall \texttt{t}.\ \left\langle \infp (\texttt{pn->n}) \ | \ \treerep\ \texttt{t} \right\rangle}} \\ 
	\texttt{traverse(pn, k)} \\ 
	\color{blue}{\langle \texttt{res} \ \texttt{n'}. \ (\texttt{res} \leftrightarrow (\texttt{pn->n'->t} = \texttt{NULL})) \ast  \infp (\texttt{pn->n'}) \ast \texttt{R(pn->n')} \ast (\texttt{k} \in \texttt{range(n')})
	\ |\ \treerep\ \texttt{t}\rangle}
\end{mathpar}

In contrast to the more complex specification of the lock-coupling style \texttt{traverse} function, the give-up template's \texttt{traverse} function has a comparatively simpler specification. The local pre-condition for the specification solely comprises $\infp(\texttt{pn->n})$, which is a footprint predicate signifying that node \texttt{n} resides within the search structure's footprint. Subsequently, the \texttt{traverse} function operates on the entire search structure, returning a subsequent node \texttt{n'} where \texttt{k} lies within the node \texttt{n'}'s range. Therefore, the local post-condition is expected to assert that \texttt{n'} is also positioned within the footprint predicate, that the resource \texttt{R(pn->n')} embodies the concrete information concerning node \texttt{n'}, and that a Boolean \texttt{res} indicates whether \texttt{pn->n'->t} is \texttt{NULL} or not.

We have defined the loop invariant for the given template of the \texttt{traverse} function as follows: 
\begin{align*} &\texttt{traverse\_inv(pn)} \triangleq\ \exists \texttt{n'}.\ \infp (\texttt{pn->n}) \ast \infp (\texttt{pn->n'})   
\end{align*}

To begin the proof, we start with the $\infp (\texttt{pn->n})$ predicate from the local pre-condition. After acquiring the lock of the node $\texttt{pn->n}$ (line 5 in Figure \ref{traverse_giveup_b}), we obtain the resource $\texttt{R(pn->n)}$ and add the additional predicate $\texttt{k} \in \texttt{range(n)}$ in the \texttt{then} of \texttt{inRange}. Similar to the proof of the lock-coupling template's \texttt{traverse}, the traversal stops when it reaches the base case, which occurs when the current node is \lstinline{NULL} (see line 8 in Figure \ref{traverse_giveup_b}). At this point, we can prove the post-condition using the specification, which indicates that $\texttt{k} \in \texttt{range(n')} \ast \texttt{pn->n'->t} = \texttt{NULL}$.

If \lstinline{findNext} cannot find a subsequent node with the key value $\texttt{k}$ within its set of key values, the function terminates. Otherwise, it successfully detects the next node (for example, \texttt{n'}) to visit, giving a predicate that asserts \texttt{n'} is in the footprint of the structure, $\infp(\texttt{pn->n})$. After releasing the lock of the current node \texttt{p} (since \texttt{p} and \texttt{n} point to the same memory address - line 6 in Figure \ref{traverse_giveup_b}), we can prove that it satisfies the loop invariant $\texttt{traverse\_inv(pn)}$ and complete this branch of the proof. In the \texttt{else} branch of the call to \texttt{inRange}, since \texttt{k} is not in the range of the current node \texttt{p}, the function gives up and relinquishes the lock on \texttt{p}, then goes back to the root of the data structure to retry.



\subsection{Templates vs. Internal Reorganization} % move to section 4?
In the binary search tree, \texttt{pushdown\_left} involves both the structure of the tree and the concurrency protocol. There's no good way to disentangle this into a template and a concurrency-free data structure operation.

\than{Or can we move this section to Proof mechanization, where we talk on BST speficially.} 

\section{Verified Data Structures}
In this section, we demonstrate how to integrate all components into high-level specifications for the purpose of verifying two template algorithms, lock-coupling and give-up, in the real C programming language.

\begin{mathpar}
	\langle \texttt{m}.\ \nodeboxrep\ \texttt{p} \ |\ \treerep\ \texttt{m}\rangle\ \texttt{insert(p, k, v)}\ \langle \nodeboxrep\ \texttt{p}\ |\ \treerep\ (\texttt{m[k} \mapsto \texttt{v])}\rangle
	
	\langle \texttt{m}.\ \nodeboxrep\ \texttt{p}\ |\ \treerep\ \texttt{m} \rangle\ \texttt{lookup(p, k)}\ \langle \texttt{v}.\ \nodeboxrep\ \texttt{p}\ |\ \treerep\ \texttt{m} \land \texttt{m(k) = v}\rangle
	
	\langle \texttt{m}.\ \nodeboxrep\ \texttt{p} \ |\ \treerep\ \texttt{m}\rangle\ \texttt{delete(p, k)}\ \langle \nodeboxrep\ \texttt{p}\ |\ \treerep\ \texttt{(m[k} \mapsto \_ \texttt{])}\rangle
\end{mathpar}

\subsection{Lock-coupling Template}
\begin{figure}[ht]
	
	\lstinputlisting[language=C, style=myStyle]{lock_insert.c} 
	\caption{The \lstinline{insert} method of the lock-coupling template algorithm}
	\label{insert_lock}	
\end{figure}

The \texttt{insert} method in Figure \ref{insert_lock} is the main method of lock-coupling template. It makes use of an auxiliary \texttt{traverse}  mentioned in Figure \ref{traverse_lock_b}. If \texttt{traverse} fails to find the next node (either to left or right), it implies that it has reached a node with a target key \texttt{k} that equals the node's value. At this point, we only have to modify the value of that to \texttt{value} (lines 4-5 in Figure \ref{insert_lock}). Otherwise, if \texttt{traverse} reaches a leaf, it allocates a new node with key \texttt{k} and value \texttt{v} by calling \texttt{insertOp(pn, k, v)} (line 9 in Figure \ref{insert_lock}).

Before moving on to the proof of \texttt{insert} operations for binary search tree, we present the specifications of helper functions, \texttt{findNext} is used in \texttt{traverse} function, and \texttt{insertOp} is used in \texttt{insert} function. They are all Hoare triples that operate on the local $\nodeboxrep$ predicate, meaning their proofs need not reason about concurrency.

\begin{figure}
	\centering
	\begin{mathpar}
		% spec of inRange
		{\color{blue}
			\left\{ 
			\begin{array}{c}
				\texttt{pn->n} \ast \texttt{n->t} \ast \texttt{t} \mapsto \texttt{(k', v', l, r)} 
			\end{array}
			\right\}
		}
		\\ 
		\texttt{findNext(pn, k)} 
		\\
		{\color{blue}
			\left\{\exists \  \texttt{res n'.}
			\begin{array}{c}
				\ \texttt{pn->n} \ \ast \ \texttt{n->t} \ \ast \ \texttt{t} \mapsto \texttt{(k', v', l, r)} \  \ast \\ 
				\ \texttt{(if res then } \texttt{(l = n'} \land \texttt{k < k')} \lor \texttt{(r = n'} \land \texttt{k > k')} \texttt{ else } \texttt{(n' = n} \land \texttt{k = k'))}
			\end{array}
			\right\}
		}
	\end{mathpar}
	\caption{Specification of \texttt{findNext} for the lock-coupling and give-up templates}
	\label{fig:findNext_lock}
\end{figure}

\begin{figure}
	\centering
	\begin{mathpar}
		% spec of inRange
		{\color{blue}
			\left\{ 
			\begin{array}{c}
				\ \texttt{pn->n} \ \ast \ \texttt{n->t} 
			\end{array}
			\right\}
		}
		\\ 
		\texttt{insertOp(pn, k, v)} 
		\\
		{\color{blue}
			\left\{\exists \  \texttt{t' l r lk1 lk2}.
			\begin{array}{c}
				\ \texttt{pn->n} \ \ast \ \texttt{n->t'} \ \ast \ \texttt{t'}\mapsto \texttt{(k, v, l, r)} \ \ast \ \\ 
				\ \texttt{l} \mapsto \texttt{(NULL, lk1)}\  \ast \ \texttt{r} \mapsto \texttt{(NULL, lk2)}
			\end{array}
			\right\}
		}
	\end{mathpar}
	\caption{Specification of \texttt{insertOp} for the lock-coupling template}
	\label{fig:insertOp_lock}
\end{figure}

The specification of \texttt{findNext} (Figure \ref*{fig:findNext_lock}) states that a non-null \texttt{t} field points to a \texttt{node} struct containing the current node's key  \texttt{k'}, the node's value \texttt{v'}, and pointers to the left \texttt{l} and right \texttt{r} child nodes. When \texttt{findNext} sucessfully locates the next node \texttt{n'}, it sets \texttt{n'} as the left child node \texttt{l} if the provided key \texttt{k} is less than the current node's key \texttt{k'}. Conversely, if the given key \texttt{k} is greater than the current node's key \texttt{k'}, the next node \texttt{n'} is set as the right child node \texttt{r}. In case where \texttt{findNext} is unable to identify the next node \texttt{n'}, it retains the current node \texttt{n} as \texttt{n'},  indicating no change and that the provided key \texttt{k} is  identical to the current node's key \texttt{k'}. 

The \texttt{insertOp} specification (Figure \ref{fig:insertOp_lock}) indicates that once \texttt{traverse} successfully reaches a leaf node (either the left or right node), the leaf node will have its \texttt{t} field set to \texttt{NULL}. This signifies that the leaf node currently has no key or value. At this location, a new node with the specified key \texttt{k} and value \texttt{v} should be inserted. Upon locating the appropriate leaf node for adding the new key-value pair \texttt{(k, v)}, the process generates two new empty child nodes with corresponding locks, \texttt{(NULL, lk1)} and \texttt{(NULL, lk2)}, which are pointed to by the \texttt{l} and \texttt{r} of the current node.  

The atomic specification for \texttt{insert} method is
\begin{mathpar}
	{\color{blue}\langle \texttt{m}.\ \nodeboxrep\ \texttt{p} \ |\ \treerep\ \texttt{m}\rangle } \ \ \texttt{insert(p, k, v)}\ 
	{\color{blue}\langle \nodeboxrep\ \texttt{p}\ |\ \treerep\ (\texttt{m[k} \mapsto \texttt{v])}\rangle }
\end{mathpar}

Similar to the \texttt{traverse} specification, the \texttt{insert} function's specification is composed of two components: local and public pre- and postconditions. The local pre- and postconditions, containing $\nodeboxrep \ \texttt{p}$, describe the binary search tree's concrete state with the root node $\texttt{p}$, which points to the node's lock and lock invariant assertion. On the other hand, the public pre- and postconditions are represented by the predicate $\treerep \ \texttt{m}$, illustrating the binary search tree's abstract state as a collection of ghost states, with each state providing information about an individual node in the tree. Here, $\texttt{m}$ and $\texttt{m[k} \mapsto \texttt{v]}$ denote the tree's abstract states before and after the function's execution, respectively.

The proof for \texttt{insert} begins with preconditions $\nodeboxrep \ \texttt{p}$ and $\treerep \ \texttt{m}$. We set \texttt{pn->n} to point to the same memory address as \texttt{*p} (line 3 in Figure \ref{insert_lock}). After the lock for the root node is acquired (line 4 in Figure \ref{insert_lock}), the thread accesses information within the root node's lock invariant, \texttt{R(pn->n)}. As seen in Section \ref{traverse_proof_lock}, we supply the same precondition for the \texttt{traverse} function, which includes local precondition $\nodeboxrep \texttt{(pn->n)} \ast \texttt{R(pn->n)}$ and public precondition $\treerep\ \texttt{m}$. We then apply the \texttt{traverse} specification from Section \ref{traverse_proof_lock}.

In the \texttt{then} branch, when the \texttt{traverse} fails to find the next node, resulting in $\texttt{res} = \texttt{false}$, it implies that $\texttt{pn->n'->t} \neq \texttt{NULL}$. This indicates that the key to be inserted already exists in the tree. In this scenario, we update the node's value while maintaining the rest of the tree structure (line 6 in Figure \ref{insert_lock}); this acts as the linearization point for the insertion. Conversely, when the \texttt{traverse} reaches a leaf and produces $\texttt{res} = \texttt{true}$, it implies $\texttt{pn->n'->t} = \texttt{NULL}$ (line 9 in Figure \ref{insert_lock}). We then utilize the \texttt{insertOp} specification, and with enough information, we can conclude that inserting the key at this location will alter the abstract state from an unknown $\texttt{m}$ to $\texttt{m[k} \mapsto \texttt{v]}$. In both instances, we must prove that we can atomically update the tree's abstract state from $\treerep \ \texttt{m}$ to $\treerep\ (\texttt{m[k} \mapsto \texttt{v])}$, by demonstrating that the in-memory tree update corresponds to a local modification in the abstract tree, which inserts the new key-value pair.


%\wm{I think this is the wrong organization. The proofs of traverse should be presented in the previous section, where we describe traverse. This section should show findNext and insert/lookup for specific data structure(s), and then describe how we combine them into top-level specs.}
\subsection{Give-up Template}

\begin{figure}[ht]
	\lstinputlisting[language=C, style=myStyle]{giveup_insert.c} 
	\caption{The \lstinline{insert} method of the give-up template algorithm}
	\label{insert_giveup}
\end{figure}


\begin{figure}
	\centering
\begin{mathpar}
	% spec of inRange
	{\color{blue}
		\left\{ 
		\begin{array}{c}
			\texttt{pn->n} \ \ast \texttt{n->t} \ \ast \ \texttt{n->min} \ \ast \ \texttt{n->max}
		\end{array}
		\right\}
	}
	\\ 
	\texttt{inRange(pn, k)} 
	\\
	{\color{blue}
		\left\{\exists \  \texttt{res.}
		\begin{array}{c}
			 \ \texttt{pn->n} \ \ast \ \texttt{n->t} \ \ast \ \texttt{n->min} \ \ast \ \texttt{n->max}\  \ast \\ 
			\ \texttt{(if res then } \texttt{(min < x} \land \texttt{x < max)} \land \texttt{(x} \leq \texttt{min} \lor \texttt{x} \geq \texttt{max))}
		\end{array}
		\right\}
	}
\end{mathpar}
\caption{Specification of \texttt{inRange} for the give-up template}
\label{fig:inRange_giveup}
\end{figure}


\begin{figure}
	\centering
	\begin{mathpar}
	%spec of insertOp
	{\color{blue}
		\left\{ 
		\begin{array}{c}
			\texttt{pn->n} \ \ast \texttt{n->t} \  \ast \texttt{n->min} \ \ast \texttt{n->max}
		\end{array}
		\right\}
	}
	\\
	\texttt{insertOp(pn, k, v)}
	\\
	{\color{blue}
	\left\{\exists \ \texttt{t' l r lk1 lk2}. 
	\begin{array}{l}
		\ \texttt{pn->n} \ \ast \ \texttt{n->t'} \ \ast \ \texttt{t'}\mapsto \texttt{(k, v, l, r)} \ \ast \ \\
		\ \texttt{l} \mapsto \texttt{(NULL, lk1, (min, x))} \ \ast \ \texttt{r} \mapsto \texttt{(NULL, lk2, (x, max))}
	\end{array}
	\right\}
	}
\end{mathpar}
\caption{Specification of \texttt{insertOp} for the give-up template}
\label{fig:insertOp_giveup}
\end{figure}

\section{Proof Mechanization}
We describe the mechanized formal verification of the correctness of such these templates, implemented in C and verified with the VST, using concurrent separation logic (CSL) to reason about the behavior of the C code, and integrated Iris-style logical atomicity into VST. All proofs are formalized in Coq using VST, and can be found online at 

\href{https://github.com/PrincetonUniversity/DeepSpecDB/tree/master/concurrency/templates}{\color{blue}{https://github.com/PrincetonUniversity/DeepSpecDB/tree/master/concurrency/templates}}




\section{Related Work}

\section{Conclusion}

%%
%% Bibliography
%% 
%% 

%% Please use bibtex, 

\bibliography{../sources}

%\appendix

%\section{Styles of lists, enumerations, and descriptions}\label{sec:itemStyles}

%List of different predefined enumeration styles:

\end{document}
