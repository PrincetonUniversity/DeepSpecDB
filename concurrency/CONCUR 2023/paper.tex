
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle
\usepackage{txfonts}
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
%% http://ctan.org/pkg/subcaption
\usepackage{uri}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{semantic}
\usepackage{graphicx}
\usepackage{cases}
\usepackage{hyperref}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage{parcolumns}
\usepackage{iris}
%\usepackage{lstlangcoq}
\usepackage[edges]{forest}
\renewcommand{\lstlistingname}{Figure}

\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000

\lstset{language=C,basicstyle=\ttfamily,
	xleftmargin=\dimexpr\fboxsep-\fboxrule,
	mathescape=true,columns=fullflexible}

\newcommand{\TODO}[1]{\textbf{\textcolor{red}{[ TODO: #1]}}}
%\newcommand{\boxdotright}{\!\mathrel\boxdot\joinrel\rightarrow\!}
\newcommand{\islock}{\boxdotright}
\newcommand{\lockvar}{\islock}
\newcommand{\isaex}{\!\mathrel\odot\joinrel\rightarrow\!}
\newcommand{\xisaex}[1]{\!\mathrel\odot\joinrel\xrightarrow{#1}\!}
%% \newcommand{\ifthenelse}[3]{\text{if }#1\text{ then }#2\text{ else }#3}
\newcommand{\emp}{\mathsf{emp}}

\newcommand\dboxed[1]{\dbox{\ensuremath{#1}}}
\newcommand{\master}[2]{\ensuremath{\mathrm{Master}_{#1}(#2)}}
\newcommand{\snap}[1]{\ensuremath{\mathrm{Snapshot}(#1)}}
\newcommand{\ghost}[2]{\ensuremath{\dboxed{#1}^{#2}}}
\newcommand{\us}{$\mu$s}
\newcommand{\gnamety}{\ensuremath{\mathsf{gname}}}
\newcommand{\treerep}{\ensuremath{\mathsf{Node}}}
\newcommand{\nodeboxrep}{\ensuremath{\mathsf{Node\_ref}}}
\newcommand{\lockinv}{\ensuremath{\mathsf{lock\_inv}}}
\newcommand{\infp}{\ensuremath{\mathsf{InFP}}}

\newcommand{\myhalf}[2]{\ensuremath{\mathsf{my\_half}_{#1}(#2)}}
\newcommand{\publichalf}[1]{\ensuremath{\mathsf{public\_half}(#1)}}

% comments from authors 
\newcommand{\than}[1]{\textbf{\textcolor{blue}{[Than: #1]}}}
\newcommand{\lb}[1]{\textbf{\textcolor{red}{[Lennart: #1]}}}
\newcommand{\wm}[1]{\textbf{\textcolor{violet}{[Willam: #1]}}}
\newcommand{\ignore}[1]{}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{myStyle}{
	backgroundcolor=\color{white},   
	commentstyle=\color{codegreen},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	keepspaces=true,                 
	numbers=left,       
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=1,
}

\title{Verifying Concurrent Search Structure Templates for C Programs using VST} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Duc Than Nguyen}{University of Illinois at Chicago, USA \and \url{http://dnguye96.people.uic.edu} }{dnguye96@uic.edu}{https://orcid.org/0000-0002-1825-0097}{(Optional) author-specific funding acknowledgements}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Lennart Beringer}{Princeton University, USA \and \url{https://www.cs.princeton.edu/~eberinge} }{eberinge@cs.princeton.edu}{https://orcid.org/0000-0002-1570-3492}{(Optional) author-specific funding acknowledgements}

\author{William Mansky}{University of Illinois at Chicago, USA\and \url{https://mansky.lab.uic.edu/} }{mansky1@uic.edu}{https://orcid.org/0000-0002-5351-895X}{(Optional) author-specific funding acknowledgements}

\author{Shengyi Wang}{Princeton University, USA \and \url{https://www.cs.princeton.edu/~shengyiw} }{shengyiw@cs.princeton.edu}{https://orcid.org/[0000-0002-2286-8703}{(Optional) author-specific funding acknowledgements}

\authorrunning{Duc Than Nguyen and William Mansky} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Duc Than Nguyen and William Mansky} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid one}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{concurrent separation logic, fine-grained locking, logical atomicity,
	Verified Software Toolchain, Iris} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Concurrent search structure templates are a technique for separating the verification of a concurrent data structure into concurrency-control and data-structure components, which can then be modularly combined with no additional proof effort. In this paper, we implement the template approach in the Verified Software Toolchain, and use it to prove correctness of C implementations of fine-grained concurrent data structures. In the process, we explore some of the practical requirements and limitations of the template approach on real code. %What's our conclusion? Are the template proofs easier/fewer lines than the proofs without the templates?
We find that the template approach is generally effective on real C implementations, although some templates require modifications to the target data structure, and some data structures have operations that are not easily decomposed. This work represents a step towards practical compositional verification of real-world concurrent data structures.
\end{abstract}

\section{Introduction}
\label{sec:introduction}
Krishna et al. proposed concurrent search structure templates~\cite{templates} as a method for separating the proof of correctness of a concurrent access method (e.g. optimistic concurrency, hand-over-hand locking, forwarding via internal links) from the proof of correctness of the underlying data structure (e.g. linked list, hashtable, B-tree). The concurrency ``templates'' are verified parametrically over data structure operations, and the data structure operations are verified without any reference to concurrency. In theory, this could allow us to prove the correctness of $n$ (single-threaded) data structure implementations and $m$ concurrency patterns, and immediately obtain $n \times m$ verified concurrent data structures. In practice, the story is more complicated: certain patterns work only for specific data structures or require the data structures to store extra information, while some internal data structure operations may not fit the template model. 

In this paper, we apply the template approach to concurrent data structure implementations in C. We verify them using the Verified Software Toolchain (VST)~\cite{plfcc}, and report on its effectiveness and the challenges we encountered. The template approach depends crucially on the idea of \emph{logically atomic specifications} introduced in TaDA~\cite{tada} and further developed in Iris~\cite{iris}. Our proofs make use of recent work that has integrated Iris-style logical atomicity into VST~\cite{iris-vst-arxiv}.

Our specific contributions are:
\begin{itemize}
\item To the best of our knowledge, this is the first mechanized verification of a template approach to concurrent data structure implementations in a real programming language.
\item 
\end{itemize}
\wm{This will be useful for contributions: Than, what would you say the hardest part was in completing the proofs?}

\than{The most challenging aspect of the project was the proofs involving traversal. It took me a considerable amount of time to understand the pre- and post-conditions, as well as determining the appropriate loop invariants. I found myself frequently switching between proving the \texttt{insertOp} and \texttt{traverse} functions in order to combine all elements. However, once I had completed the \texttt{traverse} proofs, everything became much easier.} 

\paragraph*{Related Work}
\than{I think we will write related work inside introduction part}

\section{Background}
\subsection{Concurrent Search Structure Templates}

A search structure is a data structure designed to efficiently store and retrieve data based on specific search criteria. These structures organize data to enable quick and efficient search, insertion, deletion, and traversal operations. For efficiency, many such structures are designed to allow concurrent access and modification, often employing fine-grained or lock-free concurrency to allow as many threads as possible to operate on separate parts of the data structure. Designing these search structures presents significant challenges, including ensuring correctness and consistency under concurrent access, achieving scalability by minimizing contention and maximizing parallelism, and maintaining performance and efficiency while managing synchronization and memory, including cache behavior~\cite{masstree}. The complex interplay between concurrency and data structure design in concurrent search structures makes them challenging targets for formal verification.

The Concurrent Search Structure Template approach~\cite{templates} aims make the problem tractable by separating verification of concurrency control patterns from verification of the underlying data structure. Addressing the proof of each component separately makes the individual proofs easier, and also offers the possibility of proof reuse: each verified concurrency pattern (``template'') can be applied to many different data structures, and each verified sequential data structure can be outfitted with many different templates. In theory, verifying $n$ templates and $m$ data structures might yield $n \times m$ verified concurrent data structures; in practice, as we will see, both templates and data structures make assumptions that may invalidate certain combinations. %how much more can we say about this?

We will discuss several templates in section~\ref{templates}, but broadly, a search structure template consists of a \lstinline{traverse} function that travels through a data structure in search of a particular key, using the appropriate concurrency control mechanism when moving from node to node. The node to travel to is selected by a black-box function \lstinline{findNext} provided by the data structure; all the template needs to know is that it has some way of choosing a next node to examine when the current node does not contain the target key. \wm{Show an example template here?} Once the appropriate node for the key has been found, the template returns it to a top-level function that calls out to the data structure to perform the appropriate operation (e.g. insert, lookup, delete) on that node. Thus, the \lstinline{traverse} function can be verified without knowing anything about the target data structure other than its synchronization mechanism, and without knowing anything about the operation to be performed other than that it can be performed on a single node (or sometimes a node and its parent). The job of the data structure is to implement the \lstinline{findNext} function and the specific operations; the combination of the template and the data structure is then a fully operational concurrent data structure. %what more do we want to say here?

\subsection{Iris and VST}
\than{write more here ... }

\section{Search Structure Templates in VST}

\subsection{Search Structure Templates}
\label{templates}
The C implementation of a node in our template style is:
\begin{lstlisting}[language = C, backgroundcolor=\color{white}, basicstyle=\ttfamily\footnotesize]
typedef struct node_t {node *t; lock_t *lock;} node_t;
\end{lstlisting}

Each node of type \lstinline{node_t} has a \lstinline{lock} field that protects the node and a \lstinline{t} field that points to a \lstinline{node} struct. Depending on the data structure, the \lstinline{t} field can have different interpretations. In a binary search tree, if the \lstinline{t} field is \lstinline{NULL}, it indicates a leaf node with no key or value; otherwise, it points to a \lstinline{node} struct containing the node's key, value, and child pointers. 
\begin{lstlisting}[language = C, backgroundcolor=\color{white}, basicstyle=\ttfamily\footnotesize]
typedef struct node {int key; void *value; struct node_t *left, *right;} node;
\end{lstlisting}

For a linked list, a \lstinline{t} field with \lstinline{NULL} represents the last node in the list, while a non-null \lstinline{t} field points to a \lstinline{node} struct holding the node's key, value, and a pointer to the next item in the list. 

\begin{lstlisting}[language = C, backgroundcolor=\color{white}, basicstyle=\ttfamily\footnotesize]
typedef struct node {int key; void *value; struct node_t *next;} node;
\end{lstlisting}

%For the purpose of reasoning about lock-coupling style (also known as hand-over-hand locking), we specifically consider traversing the tree using this locking method. To accomplish this, we must maintain at least one lock during traversal between nodes. This requires obtaining the lock for the next node before releasing the lock for the current node. Therefore, we utilize the \lstinline{pn} struct containing two \lstinline{node_t} type nodes: the \lstinline{p} field representing the current node, and the \lstinline{n} field denoting the next node.

\subsubsection{Lock-coupling Template}
\label{lock-coupling-algo}
The lock-coupling template employs the hand-over-hand locking scheme to prevent interference from other threads during traversal. Each thread continuously maintains at least one lock during traversal between nodes, ensuring that other threads cannot interfere with the traversal or invalidate the ongoing search.

Figure \ref{traverse_lock} shows the \lstinline{traverse} function as presented by Krishna et al. (Figure \ref{traverse_lock_a}) and the corresponding C implementation (Figure \ref{traverse_lock_b}). The C implementation uses a struct
\begin{lstlisting}[language = C, backgroundcolor=\color{white}, basicstyle=\ttfamily\footnotesize]
typedef struct pn {struct node_t *p; struct node_t *n;} pn;
\end{lstlisting}
to mimic the pair of nodes \lstinline{(p, n)} returned by the functional implementation, where \lstinline{n} is the current node and \lstinline{p} is its parent. The algorithm assumes that certain helper functions must be provided by the implementation that satisfy certain criteria. One such function, namely \lstinline{findNext}, is utilized by the algorithm to determine the next node $\texttt{n'}$ to be visited based on the current node $\texttt{n}$ and the key $\texttt{k}$. In the functional version, \lstinline{findNext} returns an \lstinline{option node}; in C, it instead returns a boolean and, if a next node is found, modifies \lstinline{pn->n}.

To ensure thread safety, it is essential to acquire and release locks in a specific order during traversal. The lock-coupling scheme achieves this by requiring threads to acquire locks in increasing order of node addresses. The thread then releases the lock for the previous node before acquiring the lock for the next node in the traversal sequence. This guarantees that the locks are acquired and released in the same order across all threads and prevents deadlocks from occurring.

\begin{figure}[ht]
	\begin{subfigure}[t]{0.45\textwidth}
		\lstinputlisting[language=caml, style=myStyle]{lock_traverse.ml} 
		\caption{The \lstinline{traverse} method of the lock-coupling template algorithm written in an ML-like language \cite{krishna2019compositional}} 
		\label{traverse_lock_a}	
	\end{subfigure}\qquad
	\begin{subfigure}[t]{0.48\textwidth}
		\lstinputlisting[language=C, style=myStyle]{lock_traverse.c} 
		\caption{The \lstinline{traverse} method of the lock-coupling template algorithm written in C}
		\label{traverse_lock_b}
	\end{subfigure}
	\caption{The \lstinline{traverse} method of the lock-coupling template algorithms}
	\label{traverse_lock}
\end{figure}

To implement the template methodology for concurrent data structure implementations in C, we have implemented the \lstinline{traverse} function in C, as depicted in Figure \ref{traverse_lock_a}.  Our version of the \lstinline{traverse} function closely resembles the one written in an ML-like language, as it relies on a helper function called \lstinline{findNext}. The purpose of \lstinline{findNext} is to determine the next node to be visited during the traversal. In our implementation, the \lstinline{traverse} function stops when it reaches the base case, which occurs when the current node is \lstinline{NULL}. Alternatively, it terminates if \lstinline{findNext} fails to find a next node that includes the key value $\texttt{k}$ in the set of key values. The \lstinline{traverse} function returns a Boolean value indicating whether it has successfully found the next node during traversal. If it fails to do so, it returns false, which other functions can use to make decisions. For instance, in a binary search tree, a node with a value of 42 would have a left child with a set of key values consisting of values less than 42 and a right child with one greater than 42. If we want to insert a new node with the target key $\texttt{k}$ into the tree, we can use the \lstinline{traverse} function to traverse the tree. When \lstinline{traverse} fails to find the next node (either to the left or right), it implies that it has reached a node with a target key $\texttt{k}$ that equals the node's value. 

When \lstinline{findNext} arrives at a new node, it acquires a lock for that node, as is the nature of hand-over-hand locking. It then releases the lock for the current node, ensuring that the link between the two nodes is not removed or rearranged while traversing it. To utilize the template methodology for concurrent data structure implementations, it is crucial to keep track of the locks acquired for each node during the traversal. 

\subsubsection{Give-Up Template}
\label{give-up-algo}
The give-up template is an algorithm for implementing concurrent search in a tree data structure. Unlike the lock-coupling template, which maintains locks during traversal between nodes, the give-up template takes an \emph{optimistic concurrency control} approach \lb{c.f. RCU}, only acquiring locks when loading or storing to a node. This reduces the amount of time that locks are held and makes the algorithm more scalable in highly-contended scenarios. Each node has a range field that serves as a reference point for threads to determine if they are still on the correct path. If a thread finds that it has deviated from the expected path, it abandons the node by releasing the lock and returns to the root node to start again. This happens when another concurrent thread restructures the data structure, invalidating the state of the current thread in between releasing one lock and acquiring another. For instance, the node we are traveling to may be moved to another part of the data structure intended to hold a different set of keys, or even deleted, before we acquire its lock.

\begin{figure}[!ht]
	\begin{subfigure}[t]{0.45\textwidth}
		\lstinputlisting[language=caml, style=myStyle]{giveup_traverse.ml} 
		\caption{The \lstinline{traverse} method of the give-up template algorithm written in ML-like language}
		\label{traverse_giveup_a}	
	\end{subfigure}\qquad
	\begin{subfigure}[t]{0.48\textwidth}
		\lstinputlisting[language=C, style=myStyle]{giveup_traverse.c} 
		\caption{The \lstinline{traverse} method of the give-up template algorithm written in C}
		\label{traverse_giveup_b}
	\end{subfigure}
	\caption{The \lstinline{traverse} method of the give-up template algorithms}
	\label{traverse_giveup}
\end{figure}

Figure \ref{traverse_giveup_a} depicts the give-up template algorithm as originally presented. The give-up template algorithm uses a helper function called \lstinline{inRange}, in addition to the \lstinline{findNext} function discussed in the previous section. The purpose of the \lstinline{inRange} function is to determine whether the key value $\texttt{k}$ falls within the range of keys held in node $\texttt{n}$ and its successors. If the key value is outside the node's range (e.g. because the node has been relocated), the search is terminated, and the thread is restarted. To implement the template algorithm, it is crucial to keep track of the lower and upper bounds of the keys present in the subtree rooted at the current node. Therefore, we have incorporated two new fields, \lstinline{min} and \lstinline{max}, into each node of type \lstinline{node_t} in our C implementation. These fields store the lower and upper bounds of the keys, respectively. In the context of binary search trees, each node is labeled with a range that is associated with a lower and upper bound on the keys. This begins with $(\texttt{min}, \texttt{max}) = (-\infty, +\infty)$ at the root node and is propagated to the empty leaf nodes. If the root node (which also serves as the parent of a node) has a key of $42$, the left leaf node's range would be $(\texttt{min}, \texttt{max}) = (-\infty, 42)$, and the right leaf node's range would be $(\texttt{min}, \texttt{max}) = (42, +\infty)$.

%\wm{Describe why we need extra pieces in the struct, and how this relates to the other version.}
\begin{lstlisting}[language = C, backgroundcolor=\color{white}, basicstyle=\ttfamily\footnotesize]
	typedef struct node_t {node *t; lock_t *lock; int min; int max;} node_t;
\end{lstlisting}

%% C implementation 


When a thread arrives at a node in search of the key $\texttt{k}$, it checks whether $\texttt{k}$ falls within the range of that node. If $\texttt{k}$ falls within the range, the thread continues by calling \lstinline{findNext} to find the new node. If $\texttt{k}$ does not fall within the range, the thread releases the lock and returns to the root node by assigning the pointer of the root to the pointer of the current node (lines 21-22 in Figure \ref{traverse_giveup_a}).

\subsection{Proofs of Templates} \than{Can someone suggest another title?}

In this section, we verify \lstinline{traverse} for both lock-coupling and give-up templates.  

For many concurrent data structures, the ideal correctness condition requires that the data structure behaves identically to a sequential implementation, even when accessed concurrently by multiple threads. The concurrent behavior of search structures is specified using \emph{atomic triples}~\cite{tada}. These take the form of $\forall a.\ \left\langle \texttt{P}_l\ |\ \texttt{P}_p(a) \right\rangle\ \texttt{c}\ \left\langle \texttt{Q}_l\ |\ \texttt{Q}_p(a)\right\rangle$, where $\texttt{P}_l$ and $\texttt{Q}_l$ are \emph{local} preconditions and postconditions, akin to a standard Hoare triple, while $\texttt{P}_p$ and $\texttt{Q}_p$ are \emph{public} preconditions and postconditions, parameterized by an abstract value $a$ of the shared data structure. This triple suggests that if $\texttt{P}_l$ holds true before a call and $\texttt{P}_p$ is true for some value of $a$ in a shared state (e.g. a global invariant), then $\texttt{P}_p$ will continue to be true for some (possibly different) value of $a$ until the \emph{linearization point} of $\texttt{c}$, at which point $\texttt{Q}_p$ will become true atomically for the same value $a$ (and $\texttt{Q}_l$ will be true after $\texttt{c}$ ends). For instance, the specification
$\forall s.\ \left\langle \texttt{is\_stack}_g\ p\ |\ \texttt{stack}_g\ s\right\rangle\ \texttt{push}(v)\ \left\langle \texttt{is\_stack}_g\ p\ |\ \texttt{stack}_g\ (v::s)\right\rangle$
expresses the fact that the push operation of a concurrent stack correctly implements the behavior of a sequential push, atomically transitioning from particular stack $s$ to $v::s$ at some point during its execution. The stack itself is treated as a publicly owned resource, and can only be accessed and modified atomically by threads holding the \texttt{is\_stack} assertion.

To demonstrate the proof of an implementation that meets the atomic specification, let's take the example of the stack specification mentioned above. This specification assert that the implementation \texttt{push} appears to execute atomically, accessing and updating the state of the data structure without exposing any intermediate states. The local preconditions and postconditions, \texttt{is\_stack}, contain the points-to and lock-invariant assertions necessary for a thread, while the public preconditions and postconditions, \texttt{stack}, involve the ghost state that defines the overall state of the stack. Ghost state is a type of program state that aids in the verification process without affecting the program's runtime behavior, and by referring to an arbitrary ghost state identifier $g$ (which we will generally omit), it is possible to connect local and public conditions. To show that the implementation of \texttt{push}(v) satisfies these atomic specifications, two things must be demonstrated. Firstly, the implementation can execute safely without owning any piece of public assertion $\texttt{stack}$, only accessing it automatically and restoring it up until the linearization point. Secondly, at some linearization point, the implementation transforms the current stack $s$ into $v::s$ atomically, which satisfies the public postcondition $\texttt{stack}(v::s)$. 

\subsubsection{Lock-coupling Template}
\label{traverse_proof_lock}
Proceeding with the proofs, we establish the following specification for the \lstinline{traverse} function in the lock-coupling template, as illustrated in Figure \ref{fig:traverse_lock}.
%\than{Try to avoid using specific name of $\mathrm{tree\_rep}$ for public condition, I suggested to use $\mathrm{Node}$ for generic purpose.} 

\begin{figure}[h]
	\centering
	\begin{mathpar}
		% spec of inRange
		{\color{blue}
			 \forall \  \texttt{m}. \left\langle
				\nodeboxrep \texttt{(pn->n)}  \ \ast \ \texttt{R(pn->n)} \ \big| \ \treerep\ \texttt{m} \
			\right\rangle
		}
		\\ 
		\texttt{traverse(pn, k)} 
		\\
		{\color{blue}
			\left\langle \exists \  \texttt{res} \ \texttt{n'}.
			\begin{array}{c}
				\ \texttt{(res} \leftrightarrow (\texttt{pn->n'->t} = \texttt{NULL))}  \ \ast \ \nodeboxrep \texttt{(pn->n')} \\  
				\ast \ \texttt{R(pn->n')} \ast \ \texttt{(k} \in \texttt{range(n'))}
			\end{array}
			\ \Bigg| \ \treerep\ \texttt{m} \
			\right\rangle
		}
	\end{mathpar}
	\caption{Specification of \texttt{traverse} for the lock-coupling template}
	\label{fig:traverse_lock}
\end{figure}

The specifics of $\nodeboxrep$ and $\treerep$ may vary across implementations, but fundamentally, $\nodeboxrep$ encompasses resources associated with each client thread, while $\treerep$ serves as an abstract representation containing ghost state that links the data structure's concrete state to its abstract equivalent, treated as an atomically accessed shared resource. In particular, $\nodeboxrep(\texttt{pn->n})$ acts as a pointer to both the node's lock and lock-invariant assertions, representing a protected resource through an arbitrary separation logic predicate. Acquiring this lock allows a thread to access additional elements within the data structure.

As previously mentioned, the \lstinline{pn} struct includes two nodes of type \lstinline{node_t}: the $\texttt{p}$ field, signifying the parent node, and the $\texttt{n}$ field, representing the current node. We use the assertion $\ell \lockvar \texttt{R}$ to associate a resource invariant \texttt{R} with a lock location $\ell$. Thus, formally, we can express $\nodeboxrep \texttt{(pn->n)} \triangleq\ \texttt{pn->n->lock} \lockvar \texttt{R(pn->n)}$.

Keep in mind that in the lock-coupling style, each thread consistently retains at least one lock while traversing between nodes, ensuring that other threads cannot interfere with the traversal or invalidate the ongoing search. Consequently, before calling the \texttt{traverse} function, the thread must acquire a lock for the current node $\texttt{pn->n}$ and obtain the resource safeguarded by the lock. This resource, represented as $\texttt{R(pn->n)}$, is parameterized by a node pointer $\texttt{pn->n}$ and describes the node's concrete information.

As mentioned earlier, we can define a piece of ghost state, $\texttt{ghost\_node t}$, connecting the node in memory to the public abstract state of the data structure. Specifically, we can have one half of the ghost state contained in the resource $\texttt{R(pn->n)}$, and the other half in the abstract state $\texttt{Node t}$. When proving the atomic triple above, at the linearization point where we access $\texttt{Node}$, we combine both halves of the ghost state, update them to reflect the new state of the concrete data structure, and then fulfill the atomic postcondition with one half of the ghost state, returning the other half to the lock invariant.

In the specification, the local pre-condition includes both the representation of the node $\nodeboxrep(\texttt{pn->n})$ and the resource $\texttt{R(pn->n)}$. When the \texttt{traverse} function operates on the entire search structure, it generates a subsequent node, \texttt{n'}, such that the key \texttt{k} falls within the range of node \texttt{n'}. The local post-condition is expected to encompass the representation of the new node $\nodeboxrep(\texttt{pn->n'})$, the resource $\texttt{R(pn->n)}$, and a Boolean variable, \texttt{res}, which indicates whether \texttt{pn->n'->t} is \texttt{NULL} or not. The key to verifying the \texttt{traverse} function is identifying the loop invariant for the top-level loop. We define the loop invariant for the lock-coupling style \texttt{traverse} function as follows:
\begin{mathpar}\texttt{traverse\_inv(pn)} \triangleq\ \exists \ \texttt{n'}.\ (\texttt{k} \in \texttt{range})\ \land \ \nodeboxrep(\texttt{pn->n'})  \ \ast \  \texttt{R(pn->n')}   
\end{mathpar}
The loop invariant mentioned above include specific existential variables (such as $\texttt{n'}$) that define the state of each iteration throughout the loop. The \lstinline{traverse} function stops when it reaches the base case, which occurs when the current node is \lstinline{NULL} (line 6 in Figure \ref{traverse_lock_b}). At this point, the specification indicates that we have $\texttt{k} \in \texttt{range(n')} \ast \texttt{pn->n'->t} = \texttt{NULL}$, enabling us to prove the post-condition. On the other hand, the function terminates if \lstinline{findNext} is unable to locate a subsequent node with the key value  $\texttt{k}$ within its set of key values (line 11 in Figure \ref{traverse_lock_b}). In this case, the specification clarifies that $\texttt{k} \in \texttt{range(n')} \ast \texttt{pn->n'->t} \neq \texttt{NULL}$ which also enables us to prove the post-condition. 

The proof begins with $\nodeboxrep \texttt{(pn->n)}$, which comprises a lock invariant $\texttt{pn->n->lock} \lockvar \texttt{R(pn->n)}$, and a resource $\texttt{R(pn->n)}$ acquired before invoking the \lstinline{traverse} function. After \lstinline{findNext} successfully detects the next node (for example, \texttt{n'}) to visit, we acquire the lock of node \texttt{n'} (line 14 in Figure \ref{traverse_lock_b}). It means we can get the resource $\texttt{R(pn->n')}$ from $\texttt{pn->n'->lock} \lockvar \texttt{R(pn->n')}$. Subsequently, we release the lock of the current node \texttt{p}. It is important to note that \texttt{p} point to the same memory address as \texttt{n} (line 4 in Figure \ref{traverse_lock_b}). By acquiring the lock for the next node \texttt{n'} before releasing the lock for the current node \texttt{p}, we ensure that the connection between the two nodes remains intact and unaltered while we traverse it (hand-over-hand locking). 
The proof concludes by verifying that the \lstinline{traverse} function fulfills the post-condition of the specification mentioned earlier.

\than{I feel somewhat perplexed while attempting to articulate the situation mentioned above. Can someone help me fix or explain it more?}

\subsubsection{Give-up Template}
\label{traverse_proof_giveup}
Moving forward with the proofs, we define the following specification for the traverse function within the give-up template, as depicted in Figure \ref{fig:traverse_giveup}.

\begin{figure}[h]
	\centering
	\begin{mathpar}
		% spec of inRange
		{\color{blue}
			\forall \  \texttt{m}. \left\langle
			\begin{array}{c}
				\infp (\texttt{pn->n}) \ \big| \ \treerep\ \texttt{m}
			\end{array}
			\right\rangle
		}
		\\ 
		\texttt{traverse(pn, k)} 
		\\
		{\color{blue}
			\left\langle \exists \  \texttt{res} \ \texttt{n'}.
			\begin{array}{c}
				\texttt{(res} \leftrightarrow (\texttt{pn->n'->t} = \texttt{NULL))}  \ \ast \infp \texttt{(pn->n')} 
				\\ 
				\ast \ \texttt{R(pn->n')} \ \ast \ (\texttt{k} \in \texttt{range(n'))}
			\end{array}
			\ \Bigg| \ \treerep\ \texttt{m} \
			\right\rangle
		}
	\end{mathpar}
	\caption{Specification of \texttt{traverse} for the give-up template}
	\label{fig:traverse_giveup}
\end{figure}

In contrast to the more complex specification of the lock-coupling style \texttt{traverse} function, the give-up template's \texttt{traverse} function has a comparatively simpler specification. The local pre-condition for the specification solely comprises $\infp(\texttt{pn->n})$, which is a footprint predicate signifying that node \texttt{n} resides within the search structure's footprint. Subsequently, the \texttt{traverse} function operates on the entire search structure, returning a subsequent node \texttt{n'} where \texttt{k} lies within the node \texttt{n'}'s range. Therefore, the local post-condition is expected to assert that \texttt{n'} is also positioned within the footprint predicate, that the resource \texttt{R(pn->n')} embodies the concrete information concerning node \texttt{n'}, and that a Boolean \texttt{res} indicates whether \texttt{pn->n'->t} is \texttt{NULL} or not.

In contrast to the lock-coupling style, where each lock is associated with a lock-invariant—an arbitrary separation logic predicate representing the protected resource acquired by a thread when the lock is obtained and must be restored upon lock release—the give-up template has a different approach. In this method, every node possesses a lock bit at location $\ell$, which is set to \texttt{True} if and only if the node is locked. This protocol is encoded into the definition of the abstract state $\treerep$. The lock protects resources denoted by \texttt{R}, which can be removed from $\treerep$ by threads when the node is locked.

Before proving the \texttt{traverse} function, let's define the loop invariant for the given template of the \texttt{traverse} function as follows:
\begin{mathpar} \texttt{traverse\_inv(pn)} \triangleq \ \exists \ \texttt{n'}.\ \infp (\texttt{pn->n}) \ast \infp (\texttt{pn->n'})   
\end{mathpar}
To begin the proof, we start with the $\infp (\texttt{pn->n})$ predicate from the local pre-condition. After acquiring the lock of the node $\texttt{pn->n}$ (line 5 in Figure \ref{traverse_giveup_b}), we obtain the resource $\texttt{R(pn->n)}$ and add the additional predicate $\texttt{k} \in \texttt{range(n)}$ in the \texttt{then} of \texttt{inRange}. Similar to the proof of the lock-coupling template's \texttt{traverse}, the traversal stops when it reaches the base case, which occurs when the current node is \lstinline{NULL} (line 8 in Figure \ref{traverse_giveup_b}). At this point, we can prove the post-condition using the specification, which indicates that $\texttt{k} \in \texttt{range(n')} \ast \texttt{pn->n'->t} = \texttt{NULL}$.

If \lstinline{findNext} cannot find a subsequent node with the key value $\texttt{k}$ within its set of key values, the function terminates. Otherwise, it successfully detects the next node (for example, \texttt{n'}) to visit, giving a predicate that asserts \texttt{n'} is in the footprint of the structure, $\infp(\texttt{pn->n})$. After releasing the lock of the current node \texttt{p} (since \texttt{p} and \texttt{n} point to the same memory address - line 6 in Figure \ref{traverse_giveup_b}), we can prove that it satisfies the loop invariant $\texttt{traverse\_inv(pn)}$ and complete this branch of the proof. In the \texttt{else} branch of the call to \texttt{inRange}, since \texttt{k} is not in the range of the current node \texttt{p}, the function gives up and relinquishes the lock on \texttt{p}, then goes back to the root of the data structure to retry.

\section{Verified Data Structures}
In this section, we demonstrate how to integrate all components into high-level specifications for the purpose of verifying two template algorithms, lock-coupling and give-up, in the real C programming language.

\than{Write more here ... }

\begin{mathpar}
	\langle \texttt{m}.\ \nodeboxrep\ \texttt{p} \ |\ \treerep\ \texttt{m}\rangle\ \texttt{insert(p, k, v)}\ \langle \nodeboxrep\ \texttt{p}\ |\ \treerep\ (\texttt{m[k} \mapsto \texttt{v])}\rangle
	
	\langle \texttt{m}.\ \nodeboxrep\ \texttt{p}\ |\ \treerep\ \texttt{m} \rangle\ \texttt{lookup(p, k)}\ \langle \texttt{v}.\ \nodeboxrep\ \texttt{p}\ |\ \treerep\ \texttt{m} \land \texttt{m(k) = v}\rangle
	
	\langle \texttt{m}.\ \nodeboxrep\ \texttt{p} \ |\ \treerep\ \texttt{m}\rangle\ \texttt{delete(p, k)}\ \langle \nodeboxrep\ \texttt{p}\ |\ \treerep\ \texttt{(m[k} \mapsto \_ \texttt{])}\rangle
\end{mathpar}

\subsection{Lock-coupling Template}
\begin{figure}[h]
	\begin{subfigure}[t]{0.48\textwidth}
	\lstinputlisting[language=C, style=myStyle, escapechar=|]{lock_insert.c} 
	\caption{The \lstinline{insert} method of the lock-coupling template algorithm}
	\label{insert_lock}	
	\end{subfigure}\qquad
    \begin{subfigure}[t]{0.48\textwidth}
    \lstinputlisting[language=C, style=myStyle]{giveup_insert.c} 
    \caption{The \lstinline{insert} method of the give-up template algorithm}
    \label{insert_giveup}
    \end{subfigure} 
\caption{The \lstinline{insert} method of the lock-coupling and give-up template algorithms}
\label{insert_lock_giveup} 
\end{figure}

The \texttt{insert} method in Figure \ref{insert_lock} is the main method of lock-coupling template. It makes use of an auxiliary \texttt{traverse}  mentioned in Figure \ref{traverse_lock_b}. If \texttt{traverse} fails to find the next node (either to left or right), it implies that it has reached a node with a target key \texttt{k} that equals the node's value. At this point, we only have to modify the value of that to \texttt{value} (lines 4-5 in Figure \ref{insert_lock}). Otherwise, if \texttt{traverse} reaches a leaf, it allocates a new node with key \texttt{k} and value \texttt{v} by calling \texttt{insertOp(pn, k, v)} (line 9 in Figure \ref{insert_lock}).

Before moving on to the proof of \texttt{insert} operations for binary search tree, we present the specifications of helper functions, \texttt{findNext} is used in \texttt{traverse} function, and \texttt{insertOp} is used in \texttt{insert} function. They are all Hoare triples that operate on the local $\nodeboxrep$ predicate, meaning their proofs need not reason about concurrency.

\begin{figure}[h]
	\centering
	\begin{mathpar}
		{\color{blue}
			\left\{ 
			\begin{array}{c}
				\texttt{pn}\mapsto\texttt{n} \ast \texttt{n}\mapsto\texttt{t} \ast \texttt{t} \mapsto \texttt{(k', v', l, r)} 
			\end{array}
			\right\}
		}
		\\ 
		\texttt{findNext(pn, k)} 
		\\
		{\color{blue}
			\left\{\exists \  \texttt{res n'.}
			\begin{array}{c}
				\texttt{pn}\mapsto\texttt{n} \ast \texttt{n}\mapsto\texttt{t} \ast \texttt{t} \mapsto \texttt{(k', v', l, r)} \\\  
				\ast \ \texttt{(if res then } \texttt{(l = n'} \land \texttt{k < k')} \lor \texttt{(r = n'} \land \texttt{k > k')} \texttt{ else } \texttt{(n = n'} \land \texttt{k = k'))}
			\end{array}
			\right\}
		}
	\end{mathpar}
	\caption{Specification of \texttt{findNext} for the lock-coupling and give-up templates}
	\label{fig:findNext_lock}
\end{figure}

\begin{figure}[h]
	\centering
	\begin{mathpar}
		{\color{blue}
			\left\{ 
			\begin{array}{c}
				\ \texttt{pn}\mapsto\texttt{n} \ \ast \ \texttt{n}\mapsto\texttt{t} 
			\end{array}
			\right\}
		}
		\\ 
		\texttt{insertOp(pn, k, v)} 
		\\
		{\color{blue}
			\left\{\exists \  \texttt{t' l r lk1 lk2}.
			\begin{array}{c}
				\ \texttt{pn} \mapsto \texttt{n} \ \ast \ \texttt{n}\mapsto \texttt{t'} \ \ast \ \texttt{t'}\mapsto \texttt{(k, v, l, r)} \ \ast \ \\ 
				\ \texttt{l} \mapsto \texttt{(NULL, lk1)}\  \ast \ \texttt{r} \mapsto \texttt{(NULL, lk2)}
			\end{array}
			\right\}
		}
	\end{mathpar}
	\caption{Specification of \texttt{insertOp} for the lock-coupling template}
	\label{fig:insertOp_lock}
\end{figure}

The specification of \texttt{findNext} (Figure \ref*{fig:findNext_lock}) states that a non-null \texttt{t} field points to a \texttt{node} struct containing the current node's key  \texttt{k'}, the node's value \texttt{v'}, and pointers to the left \texttt{l} and right \texttt{r} child nodes. When \texttt{findNext} sucessfully locates the next node \texttt{n'}, it sets \texttt{n'} as the left child node \texttt{l} if the provided key \texttt{k} is less than the current node's key \texttt{k'}. Conversely, if the given key \texttt{k} is greater than the current node's key \texttt{k'}, the next node \texttt{n'} is set as the right child node \texttt{r}. In case where \texttt{findNext} is unable to identify the next node \texttt{n'}, it retains the current node \texttt{n} as \texttt{n'},  indicating no change and that the provided key \texttt{k} is  identical to the current node's key \texttt{k'}. 

The \texttt{insertOp} specification (Figure \ref{fig:insertOp_lock}) indicates that once \texttt{traverse} successfully reaches a leaf node (either the left or right node), the leaf node will have its \texttt{t} field set to \texttt{NULL}. This signifies that the leaf node currently has no key or value. At this location, a new node with the specified key \texttt{k} and value \texttt{v} should be inserted. Upon locating the appropriate leaf node for adding the new key-value pair \texttt{(k, v)}, the process generates two new empty child nodes with corresponding locks, \texttt{(NULL, lk1)} and \texttt{(NULL, lk2)}, which are pointed to by the \texttt{l} and \texttt{r} of the current node.  

The atomic specification for \texttt{insert} method is
\begin{mathpar}
	{\color{blue}
		\texttt{m.}\left\langle 
		\nodeboxrep\ \texttt{p} \ \big | \ \treerep\ \texttt{m}
		\right\rangle
	}
	\ \texttt{insert(p, k, v)}\ 
	{\color{blue}
		\left\langle 
		\nodeboxrep\ \texttt{p} \ \big | \ \treerep\ (\texttt{m[k} \mapsto \texttt{v])}
		\right\rangle
	}
\end{mathpar}

Similar to the \texttt{traverse} specification, the \texttt{insert} function's specification is composed of two components: local and public pre- and postconditions. The local pre- and postconditions, containing $\nodeboxrep \ \texttt{p}$, describe the binary search tree's concrete state with the root node $\texttt{p}$, which points to the node's lock and lock invariant assertion. On the other hand, the public pre- and postconditions are represented by the predicate $\treerep \ \texttt{m}$, illustrating the binary search tree's abstract state as a collection of ghost states, with each state providing information about an individual node in the tree. Here, $\texttt{m}$ and $\texttt{m[k} \mapsto \texttt{v]}$ denote the tree's abstract states before and after the function's execution, respectively.

The proof for \texttt{insert} begins with preconditions $\nodeboxrep \ \texttt{p}$ and $\treerep \ \texttt{m}$. We set \texttt{pn->n} to point to the same memory address as \texttt{*p} (line 3 in Figure \ref{insert_lock}). After the lock for the root node is acquired (line 4 in Figure \ref{insert_lock}), the thread accesses information within the root node's lock invariant, \texttt{R(pn->n)}. As seen in Section \ref{traverse_proof_lock}, we supply the same precondition for the \texttt{traverse} function, which includes local precondition $\nodeboxrep \texttt{(pn->n)} \ast \texttt{R(pn->n)}$ and public precondition $\treerep\ \texttt{m}$. We then apply the \texttt{traverse} specification from Section \ref{traverse_proof_lock}.

In the \texttt{then} branch, when the \texttt{traverse} fails to find the next node, resulting in $\texttt{res} = \texttt{false}$, it implies that $\texttt{pn->n'->t} \neq \texttt{NULL}$. This indicates that the key to be inserted already exists in the tree. In this scenario, we update the node's value while maintaining the rest of the tree structure (line 6 in Figure \ref{insert_lock}); this acts as the linearization point for the insertion. Conversely, when the \texttt{traverse} reaches a leaf and produces $\texttt{res} = \texttt{true}$, it implies $\texttt{pn->n'->t} = \texttt{NULL}$ (line 9 in Figure \ref{insert_lock}). We then utilize the \texttt{insertOp} specification, and with enough information, we can conclude that inserting the key at this location will alter the abstract state from an unknown $\texttt{m}$ to $\texttt{m[k} \mapsto \texttt{v]}$. In both instances, we must prove that we can atomically update the tree's abstract state from $\treerep \ \texttt{m}$ to $\treerep\ (\texttt{m[k} \mapsto \texttt{v])}$, by demonstrating that the in-memory tree update corresponds to a local modification in the abstract tree, which inserts the new key-value pair. 
Next, we release (line 11 in Figure \ref{insert_lock}) the node \texttt{n} and return it to the shared state. Subsequently, we demonstrate the postcondition of the \texttt{insert} function to complete the proof.


%\wm{I think this is the wrong organization. The proofs of traverse should be presented in the previous section, where we describe traverse. This section should show findNext and insert/lookup for specific data structure(s), and then describe how we combine them into top-level specs.}
\subsection{Give-up Template}

Using the give-up template, the \texttt{insert} method in Figure \ref{insert_giveup} is not significantly different from the \texttt{insert} method of the lock-coupling template.  The primary distinction is that it does not require acquiring a lock before calling the \texttt{traverse} function. Furthermore, it utilizes an auxiliary \texttt{traverse} function, as illustrated in Figure \ref{fig:traverse_giveup}.  This function shares the same objective as the previously discussed \texttt{traverse} function in the lock-coupling approach.

The give-up template retains the specification of the \texttt{findNext} helper function from the lock-coupling template while introducing an extra helper function called \texttt{inRange}. Additionally, the \texttt{insertOp} specification exhibits subtle differences from that of the lock-coupling template, as it incorporates two new fields,  \texttt{min} and \texttt{max},  into each \texttt{node\_t} type node, as showcased in Section  \ref{give-up-algo}. 

\begin{figure}[h]
	\centering
	\begin{mathpar}
		% inRange for give-up
		{\color{blue}
			\left\{ 
			\begin{array}{c}
				\texttt{pn}\mapsto\texttt{n} \ \ast \texttt{n}\mapsto\texttt{(t, lock, min, max)} 
			\end{array}
			\right\}
		}
		\\ 
		\texttt{inRange(pn, k)} 
		\\
		{\color{blue}
			\left\{\exists \  \texttt{res.}
			\begin{array}{c}
				\ \texttt{pn}\mapsto\texttt{n} \ \ast \ \texttt{n}\mapsto\texttt{(t, lock, min, max)} \  \\ 
				\ \ast  \ \texttt{(if res then } \texttt{(min < k} \land \texttt{k < max)} \land \texttt{(k} \leq \texttt{min} \lor \texttt{k} \geq \texttt{max))}
			\end{array}
			\right\}
		}
		\\
		\\
		%insertOp for give-up
		{\color{blue}
			\left\{ 
			\begin{array}{c}
				\texttt{pn}\mapsto\texttt{n} \ \ast \ \texttt{n}\mapsto\texttt{t} \  \ast \ \texttt{n}\mapsto\texttt{min} \ \ast \ \texttt{n}\mapsto\texttt{max}
			\end{array}
			\right\}
		}
		\\
		\texttt{insertOp(pn, k, v)}
		\\
		{\color{blue}
			\left\{\exists \ \texttt{t' l r lk1 lk2}. 
			\begin{array}{c}
				\ \texttt{pn}\mapsto\texttt{n} \ \ast \ \texttt{n}\mapsto\texttt{t'} \ \ast \ \texttt{t'}\mapsto \texttt{(k, v, l, r)} \\ 
				\ \ast \ \texttt{l} \mapsto \texttt{(NULL, lk1, (min, k))} \ \ast \ \texttt{r} \mapsto \texttt{(NULL, lk2, (k, max))}
			\end{array}
			\right\}
		}
	\end{mathpar}
	\caption{Specifications of \texttt{inRange} and \texttt{insertOp} for the give-up template}
	\label{fig:inRange_insertOp_giveup}
\end{figure}

The \texttt{inRange} specification (Figure \ref{fig:inRange_insertOp_giveup}) simply necessitates that \texttt{inRange(pn, k)}  yields a boolean value, \texttt{res}. When \texttt{res} is \texttt{True}, it signifies that \texttt{k} is within the range of \texttt{(min, max)} associated with the node \texttt{n}. 
Conversely, \texttt{res} is \texttt{False}, it indicates that \texttt{k} is outside the boundaries of \texttt{(min, max)}. 

As previously mentioned, the \texttt{insertOp} specification (Figure \ref{fig:inRange_insertOp_giveup}) exhibits slight differences from that of the lock-coupling template, primarily due to the incorporation of two extra fields. As a result, node \texttt{n} needs point-to predicates for these new fields. Moreover, the current node's \texttt{l} and \texttt{r} point to two new empty child nodes with associated locks and ranges: \texttt{(NULL, lk1, (min, k))} and \texttt{(NULL, lk2, (k, max))}.  In the context of binary search trees, a node inherits its range from its parent based on the parent's key; thus, if node \texttt{n} has range \texttt{(min, max)} and key \texttt{k}, its left child will have the range \texttt{(min, k)} and its right child the range \texttt{(k, max)}. 




While the \texttt{insert} specification interface for the give-up template is identical to that of the lock-coupling template, a few adjustments need to be made within $\nodeboxrep\ \texttt{p}$ and $\treerep \ \texttt{m}$. Essentially, the \texttt{insert} function's specification comprises two main components: local and public preconditions and postconditions, as previously mentioned. Moreover, we must demonstrate that it is possible to atomically update the tree's abstract state from an unknown \texttt{m} to $\texttt{m[k} \mapsto \texttt{v])}$.

The local preconditions and postconditions, containing $\nodeboxrep \ \texttt{p}$, depict the binary search tree's concrete state, where the root node $\texttt{p}$ points to the node's lock and footprint predicate, signifying that the root node is located within the search structure's footprint. In contrast, the public preconditions and postconditions are denoted by the predicate  $\treerep \ \texttt{m}$, which is identical to the public predicates of the \texttt{traverse} function in the give-up template. 

The proof for the \texttt{insert} operation begins with the preconditions $\nodeboxrep \ \texttt{p}$ and $\treerep \ \texttt{m}$. We assign \texttt{pn->n} to point to the same memory address as \texttt{*p} (line 3 in Figure \ref{insert_giveup}). In Section \ref{traverse_proof_giveup}, we discuss providing the identical preconditions for the \texttt{traverse} function, which encompasses the local precondition $\infp(\texttt{pn->n})$ and the public precondition $\treerep\ \texttt{m}$. Subsequently, we apply the \texttt{traverse} specification from Section \ref{traverse_proof_giveup}.

Analogous to the lock-coupling template's \texttt{insert} operation, there are two possible branches representing the outcome following the execution of \texttt{traverse}. Once we demonstrate the ability to atomically update the tree's abstract state from $\treerep \ \texttt{m}$ to $\treerep\ (\texttt{m[k} \mapsto \texttt{v])}$, we proceed by releasing the node \texttt{n} and returning it to the shared state, thereby finalizing the proof.



\subsection{Templates vs. Internal Reorganization} % move to section 4?
In the binary search tree, \texttt{pushdown\_left} involves both the structure of the tree and the concurrency protocol. There's no good way to disentangle this into a template and a concurrency-free data structure operation.

\than{Write more ...}

\section{Proof Mechanization}
We present the mechanized formal verification of the correctness of these templates, which are implemented in C and verified with the Verified Software Toolchain. We employ concurrent separation logic to analyze the behavior of the C code and incorporate Iris-style logical atomicity within VST.

\begin{table}[h]
	\begin{center}
		\begin{tabular}{l | c || l | c } 
			\hline
			\textbf{Lock-coupling template} & \textbf{Line of proofs} & \textbf{Give-up  template} & \textbf{Line of proofs} \\
			\hline
			Template specfications & 190 & Template specfications & 138 \\
			\texttt{findNext} proof 	& 27  & \texttt{findNext} proof & 27 \\
			\texttt{insertOp} proof 	& 32  & \texttt{insertOp} proof & 31 \\
			& & \texttt{inRange} proof & 30 \\
			\texttt{traverse} proof	& 360  & \texttt{traverse} proof & 336 \\ 
			\texttt{insert} proof 	   		& 450  & \texttt{insert} proof & 284 \\
			\texttt{lookup} proof 	   	& 235  &  \texttt{lookup} proof & 304 \\ 
			\texttt{pushdown\_left} proof 	   	& 282 & & \\	
			\texttt{delete} proof 		& 182	 &   & 	 \\
			supporting proofs    & 	1909	 & supporting proofs 	& 1876 \\
			\hline
			\textbf{Total} & \textbf{3667} & & \textbf{3026}  
		\end{tabular}
		\caption{Size of Coq definitions and proofs, by topic.}
		\label{table_coq}
	\end{center}
\end{table}

By utilizing VST, we can create programs in standard C, automatically generate abstract syntax trees (ASTs) for them in Coq, and subsequently state and interactively prove specifications for these programs with the support of automated tactics. Table \ref{table_coq} presents a summary of our Coq development. We formalized all previously described proofs in Coq, taking advantage of VST's features for verifying separation logic specifications of C functions. This encompasses supplementary proofs, template specifications (encompassing all helper functions such as \texttt{findNext}, \texttt{insertOp}, and others, in addition to \texttt{traverse}, \texttt{insert}, \texttt{lookup}, and \texttt{delete}), as well as proofs against with lock-coupling and give-up template specifications. All proofs are formalized in Coq using VST and can be found online at

\href{https://github.com/PrincetonUniversity/DeepSpecDB/tree/master/concurrency/templates}{\color{blue}{https://github.com/PrincetonUniversity/DeepSpecDB/tree/master/concurrency/templates}}

\section{Conclusion}

%%
%% Bibliography
%% 
%% 

%% Please use bibtex, 
\newpage
\bibliography{../sources}

%\appendix

%\section{Styles of lists, enumerations, and descriptions}\label{sec:itemStyles}

%List of different predefined enumeration styles:

\end{document}
