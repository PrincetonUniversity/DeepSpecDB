\documentclass[a4paper,USenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\usepackage{txfonts}
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{uri}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{semantic}
\usepackage{graphicx}
\usepackage{cases}
\usepackage{hyperref}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage{iris}
%\usepackage{lstlangcoq}
\usepackage[edges]{forest}
\renewcommand{\lstlistingname}{Figure}

\clubpenalty = 10000
\widowpenalty = 10000
\displaywidowpenalty = 10000

\lstset{language=C,basicstyle=\ttfamily,mathescape=true,columns=fullflexible}

\newcommand{\TODO}[1]{\textbf{\textcolor{red}{[ TODO: #1]}}}
%\newcommand{\boxdotright}{\!\mathrel\boxdot\joinrel\rightarrow\!}
\newcommand{\islock}{\boxdotright}
\newcommand{\lockvar}{\islock^{v}}
\newcommand{\isaex}{\!\mathrel\odot\joinrel\rightarrow\!}
\newcommand{\xisaex}[1]{\!\mathrel\odot\joinrel\xrightarrow{#1}\!}
%% \newcommand{\ifthenelse}[3]{\text{if }#1\text{ then }#2\text{ else }#3}
\newcommand{\emp}{\mathsf{emp}}

\newcommand\dboxed[1]{\dbox{\ensuremath{#1}}}
\newcommand{\master}[2]{\ensuremath{\mathrm{Master}_{#1}(#2)}}
\newcommand{\snap}[1]{\ensuremath{\mathrm{Snapshot}(#1)}}
\newcommand{\ghost}[2]{\ensuremath{\dboxed{#1}^{#2}}}
\newcommand{\us}{$\mu$s}
\newcommand{\gnamety}{\ensuremath{\mathsf{gname}}}
\newcommand{\treerep}{\ensuremath{\mathsf{bst}}}
\newcommand{\nodeboxrep}{\ensuremath{\mathsf{bst\_ref}}}

\newcommand{\myhalf}[2]{\ensuremath{\mathsf{my\_half}_{#1}(#2)}}
\newcommand{\publichalf}[1]{\ensuremath{\mathsf{public\_half}(#1)}}

\newcommand{\ignore}[1]{}

\hyphenation{Comp-Cert}

\usepackage[utf8]{inputenc}

\title{Proving Atomic Specifications for Data Structures with Fine-Grained Locking}
\author{Roshan Sharma}{University of Illinois at Chicago, USA}{}{}{}
\author{Shengyi Wang}{Princeton University, USA}{}{}{}
\author{Alexander Oey}{, USA}{}{}{}
\author{Anastasiia Evdokimova}{University of Illinois at Chicago, USA}{}{}{}
\author{Lennart Beringer}{Princeton University, USA}{}{}{}
\author{William Mansky}{University of Illinois at Chicago, USA}{}{}{}

\authorrunning{R. Sharma, S. Wang, A. Oey, A. Evdokimova, L. Beringer, and W. Mansky} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Roshan Sharma, Shengyi Wang, Alexander Oey, Anastasiia Evdokimova, Lennart Beringer, and William Mansky} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid one}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{Dummy keyword} %TODO mandatory; please add comma-separated list of keywords

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}
abstract
\end{abstract}

% Contributions:
% verified C implementation of BST -- the first?
% technique for hand-over-hand locking with share accounting -- slight modification of Gotsman's for logics without held predicates that remember the invariant; amounts to converting Locked_I into another share of the lock assertion
% technique for connecting locks with abstract state/atomicity
% VST-style decomposition of proofs into C-to-local-abstract and local-to-global-abstract
% lock-free implementation?

\section{Introduction}
\input{intro.tex}

\section{Background}
\label{background}
\subsection{VST and Iris}

We use the Verified Software Toolchain \cite{plfcc}  to prove the correctness of the concurrent binary search tree. VST is a Coq-based proof system that helps to prove separation logic properties of C programs with the assurance that the properties will be preserved in compiled code. First, we write programs in C programming and using CompCertâ€™s \emph{clightgen}, the ASTs for C programs can be generated in Coq. We then state and prove specifications for them using Verifiable C. Verifiable C is a higher-order separation logic for reasoning about the functional correctness of C programs and carries a soundness proof that links high-level specifications to assembly code generated by the CompCert Verified compiler. Verifiable C supports reasoning about two separate kinds of concurrency:  Pthreads-style concurrency with locks (used by implementing blocking data structures that can be fine-grained or coarse-grained ), and concurrency using C11 atomic operations (i.e. lock-free data structures). 

\ignore{\subsection{Ghost State and Global Invariants}
We can prove memory safety and race freedom properties of shared-memory concurrent programs, by tracking the transfer of ownership of shared locations between threads that would happen if we ran the program. But, this idea is insufficient to prove that concurrently running threads are successful to accomplish some task, which is also called functional correctness. For instance, we can prove the memory safety properties of the increment example in  \ref{figure1} through the transfer of ownership of shared variable $x$ between threads. But, we can not guarantee that the value of $x$ will be $2$ after all threads complete their execution, which is demonstrated in \ref{figure1} using separation logic assertion.   
\begin{figure}[htb]
\centering
$\texttt{x = 0;}$\\
$\mathit{I_{\pi}(x \mapsto v \land v \geq 0)}\qquad\pi = \pi_1\ .\ \pi_2$\\
$\begin{array}{l || l}
\mathit{I_{\pi_1}(x \mapsto v \land v \geq 0)} & \mathit{I_{\pi_2}(x \mapsto v \land v \geq 0)}\\
\texttt{acquire(l);} & \texttt{acquire(l);}\\
\mathit{x \mapsto v \land I_{\pi_1}(x \mapsto v \land v \geq 0)} & \mathit{x \mapsto v \land I_{\pi_2}(x \mapsto v \land v \geq 0)}\\
\texttt{x++;} & \texttt{x++;}\\
\mathit{x \mapsto v+1 \land I_{\pi_1}(x \mapsto v \land v \geq 0)} & \mathit{x \mapsto v+1 \land I_{\pi_2}(x \mapsto v \land v \geq 0)}\\
\texttt{release(l);} & \texttt{release(l);}\\
\mathit{I_{\pi_1}(x \mapsto v \land v \geq 0)} & \mathit{I_{\pi_2}(x \mapsto v \land v \geq 0)}\\
\end{array}$\\
$\mathit{I_{\pi}(x \mapsto v \land v \geq 0)}$
\caption{The increment example annotated with separation logic assertion}
\label{figure1}
\end{figure}
We must preserve the connection between the value of shared resources and the work performed by each thread. A common approach to achieve this is to use \emph{ghost variables}, an auxiliary state introduced later in the proof to track the local information about each thread. They do not appear in the original program. Program in \ref{figure1} can be verified by creating ghost state, which tracks the latest action performed by a thread, for each thread with initial value of $0$, and update with $1$ after each thread increment the value of \texttt{x}. In VST, we can create \emph{ghost state} for any Coq type in the form of an arbitrary \emph{partial commutative monoid} (PCM), a set with a partially defined binary operation that is as associative as it can, commutative, and has a unit, as long as we can describe what happens when two elements of that type are joined together. VST provides $\mathsf {ghost\_var}$ assertion to create a simple ghost state: $\mathsf{ghost\_var}\ \mathit{sh}\ a\ g$ asserts that $g$ is a \emph{ghost name} ($\gnamety$ in Coq) associated with the value $a$, which may be of any type. We will see different kind of ghost states used to verify binary search tree in the following sections.

The main idea behind the logic from Iris \cite{higherorderghoststate}, a mechnized higher-order concurrent separation logic framework, is the construction of \emph{global invariant} as \emph{ghost state}. \emph{Global Invariant} is an invariant on the global (ghost and physical) state of program. We can open any invariant but must close it again before taking any steps of execution unless those execution are atomic. Thread can use the contents of \emph{global invariant} during atomic operation if it can guarantee that no one will ever see an intermediate state in which invariant does not hold. The rules from Jung et al.\cite{higherorderghoststate} for creating and opening invariants are:

\begin{mathpar}
\inference[\textsf{inv\_alloc}]{}{\triangleright P \vdash \pvs[E] \mathsf{EX}\ i : \mathsf{iname}, \knowInv{i}{P}}

\inference[\textsf{inv\_open}]{i \in E}{\knowInv{i}{P} \vdash \pvs[E][E \setminus i] \triangleright P * (\triangleright P \wand \pvs[E \setminus i][E] \mathsf{emp})}
\end{mathpar}

where invariants are provided in the form of assertion $\knowInv{i}{P}$, and states that $P$ is maintained as an invariant on the global state with name $i$. The operator%%  $\pvs[][]$
is called ``fancy update" operator,that allows to allocate, open, and close the invariants and the later $\triangleright$ operator is used for impredicativity (i.e. $\knowInv{i}{..\knowInv{i}{P}..}$).}

\subsection{Hand-over-Hand Locking}
\label{selflock}

Hand-over-hand locking (also called lock coupling) is a fine-grained locking pattern for traversing a data structure in which we acquire the lock for the next node before releasing the lock for the current node, thus guaranteeing that the link between the two nodes is not removed or rearranged while we traverse it. Hand-over-hand locking is a classic example of a pattern that requires reference to lock invariants inside other lock invariants, dating back to the earliest papers on ``predicates in the heap'' in CSL~\cite{gotsman}. The trick is to assign each node in the data structure a lock invariant that includes the lock assertion for its child nodes; for a linked list, for instance, we might write $R(n) \triangleq n \mapsto (d, n', \ell') * \ell' \islock R(n')$, where $n'$ is the child of $n$ and $\ell'$ is $n'$'s lock. By acquiring $n$'s lock, we learn the lock assertion for $n'$, and can acquire its lock as needed before releasing $n$.

This invariant becomes slightly more complicated when we consider \emph{ownership} of locks, as is required if we want to eventually free the lock and return its resources. In this case the lock assertion carries a share $\pi$, where the full share $\pi = 1$ is required to free the lock, while any share is sufficient to acquire or release it. We can amend our lock invariant to $R(n) \triangleq n \mapsto (d, n', \ell') * \ell' \islock_\pi R(n')$ for some suitable share $\pi$, but then, what happens to the share of $n_1$'s lock when we release the lock on $n$? Starting from a state in which we hold $n$'s lock $\ell$, this gives us:
\begin{align*}
&\{ \ell \islock_\pi R(n) * n \mapsto (d, n', \ell') * \ell' \islock_\pi R(n') \}\\
&\texttt{acquire}(\ell');\\
&\{ \ell \islock_\pi R(n) * n \mapsto (d, n', \ell') * \ell' \islock_\pi R(n') * n' \mapsto (d, n'', \ell'') * \ell'' \islock_\pi R(n'') \}\\
&\texttt{release}(\ell);\\
&\{ \ell \islock_\pi R(n) * n' \mapsto (d, n'', \ell'') * \ell'' \islock_\pi R(n'') \}
\end{align*}
In order to re-establish $\ell$'s lock invariant $R(n)$, we must give up our knowledge of $n'$'s lock $\ell'$. This leaves us with two problems: we have no lock assertion for $\ell'$, so we will be unable to release it later, and we still have partial ownership of $\ell$'s lock assertion, without any way to re-collect our share. Both of these problems can be solved by making the lock \emph{recursive}, including a share of the lock assertion in its own lock invariant\footnote{Gotsman et al. instead use a separation assertion $\mathsf{Locked}$ that is always held by the thread that acquires a lock, and is required to free the lock: this is equivalent to an extra share of the lock assertion.}:
$$R(n) \triangleq \ell \islock_{\pi_1} R(n) * n \mapsto (d, n', \ell') * \ell' \islock_{\pi_2} R(n')$$

Share $\pi_1$ of each lock is held by the lock itself, while share $\pi_2$ is held by its parent. Then the same sequence of operations gives us:
\begin{align*}
&\{ \ell \islock_{\pi_1} R(n) * n \mapsto (d, n', \ell') * \ell' \islock_{\pi_2} R(n') \}\\
&\texttt{acquire}(\ell');\\
&\{ \ell \islock_{\pi_1} R(n) * n \mapsto (d, n', \ell') * \ell' \islock_{\pi_2} R(n') * \ell' \islock_{\pi_1} R(n') * n' \mapsto (d, n'', \ell'') * \ell'' \islock_{\pi_2} R(n'') \}\\
&\texttt{release}(\ell);\\
&\{ \ell' \islock_{\pi_1} R(n') * n' \mapsto (d, n'', \ell'') * \ell'' \islock_{\pi_2} R(n'') \}
\end{align*}
Now, when we acquire $\ell'$, we hold both $\pi_1$ and $\pi_2$ of its lock assertion; when we release $\ell$, we return our share $\pi_1$ of $\ell$ along with share $\pi_2$ of $\ell'$, but retain share $\pi_1$ of $\ell'$, so we can release it later. The details of defining a lock invariant that includes a share of its own lock assertion may vary across separation logics (VST provides a $\mathsf{selflock}$ assertion for exactly this purpose), but as long as it is possible, this pattern can be used to implement hand-over-hand lock invariants with share accounting, allowing us to traverse a data structure built with this pattern and then reclaim all of its resources once all threads are finished with it.

\subsection{Atomic Specifications}
\label{atomic}

For many concurrent data structures, the ideal correctness condition is that the data structure behaves the same as a sequential implementation, even when accessed simultaneously by multiple threads. This intuitive condition can be formalized as linearizability (operations appear to take effect in some total order) or atomicity (client threads never observe intermediate states of operations). In separation logic, atomicity can be expressed in the form of \emph{atomic triples}~\cite{tada}, written in the form $\forall a.\ \langle P_l\ |\ P_p(a)\rangle\ c\ \langle Q_l\ |\ Q_p(a)\rangle$, where $P_l$ and $Q_l$ are \emph{private} pre- and postconditions similar to an ordinary Hoare triple, and $P_p$ and $Q_p$ are \emph{public} pre- and postconditions, parameterized by an abstract value $a$ of the shared data structure. Intuitively, $P_l$ and $Q_l$ must be true before and after the call, while $P_p$ must be true for some value of $a$ at every point from the beginning of $c$ until some designated linearization point, at which point $Q_p$ becomes true atomically for the same value $a$. For instance, the specification $$\forall s.\ \langle \mathsf{is\_stack}\ p\ |\ \mathsf{stack}\ s\rangle\ \texttt{push}(v)\ \langle \mathsf{is\_stack}\ p\ |\ \mathsf{stack}\ (v :: s)\rangle$$ expresses the fact that the \texttt{push} operation of a concurrent stack correctly implements the behavior of a sequential push, atomically transitioning from some stack $s$ to $v :: s$ at some point during its execution. %maybe something about linking ghost state, which parts are real vs. ghost, accessing invariants around atomic triple

VST has encoded an atomic Hoare triple, and provide the way that matches the notation VST uses for normal specifications. Such specification is called \emph{atomic specification}, and can be formalized in Coq as shown in  \ref{atomic-spec}.  This is how we write pre- and postcondition in VST. 
\begin{figure}[htb]
\centering
\begin{verbatim}
Program Definition insert_spec :=
DECLARE _insert
ATOMIC TYPE W OBJ a INVS Ei Eo
WITH ...
PRE [ ... ]
  PROP (...)
  LOCAL (...)
  SEP (P_l) | (P_p)
POST [ ... ]
  PROP ()
  LOCAL ()
  SEP (Q_l) | (Q_p)
\end{verbatim}
\caption{Atomic Specification in VST}
\label{atomic-spec}
\end{figure}
\texttt{W} is the \textsf{TypeTree} representing the type of arguments passed with \texttt{WITH} clause; \texttt{a} is the abstract state for the triple; \texttt{Ei} and \texttt{Eo} are the sets of invariants names inside and outside the triple. The \texttt{PROP} clause describes things that that are true independent of program state, the \texttt{LOCAL} clause describes the values contained in C local variables, and the \texttt{SEP} clause represents the \emph{separating conjunction} (*) of \emph{spatial predicates}, predicates on some part of the memory. In VST, while proving that a function implements an atomic specification, the precondition will contains an $\mathsf{atomic\_shift}$ assertion with the public pre- and postcondition, and the masks inside it. This atomic shift can be accessed through following two rules:
$$\inference[\textsf{atomic\_commit}]{\forall a, R * P_p\ a \Rrightarrow \mathsf{EX}\ y,\ Q_p\ a\ y * R'\ y}{\textsf{atomic\_shift}(P_p, E_i, E_o, Q_p, Q) * R \Rrightarrow \mathsf{EX}\ y,\ Q\ y * R'\ y}$$
$$\inference[\textsf{atomic\_rollback}]{\forall a, R * P_p\ a \Rrightarrow P_p\ a * R'}{\textsf{atomic\_shift}(P_p, E_i, E_o, Q_p, Q) * R \Rrightarrow \textsf{atomic\_shift}(P_p, E_i, E_o, Q_p, Q) * R'}$$
During commit, we must provide resources $R$ which, in combination with the public precondition $P_p$, allow us to prove the public postcondition $Q_p$. Then, we gain access to an assertion $Q$ required by the postcondition of the function, and leftover resources $R'$. During rollback, we provide resources $R$ which, in combination with the public precondition, allow us to reestablish the public precondition; we then regain the atomic shift back in the proof, as well as leftover resources $R'$. The rollback is specially used to learn some relationship between pieces of information (e.g. ghost state) stored in the public precondition, while the commit is used to prove the public postcondition from the precondition, and obtain an assertion $Q$. To complete the proof of any function's specification, we must always perform commit to obtain $Q$; we can perform any number of rollbacks before that point, but after that point we lose the atomic shift and no access to the public precondition.

\section{Locks and Atomicity}
    
\section{BST with Hand-over-Hand Locking}
\label{hand-over-hand}
As described in section~\ref{atomic}, we want the operations of our concurrent BSTs to satisfy atomic triples relating them to sequential operations:
\begin{mathpar}
\forall t.\ \langle \nodeboxrep\ p\ |\ \treerep\ t\rangle\ \texttt{insert}(p, k, v)\ \langle \nodeboxrep\ p\ |\ \treerep\ (\mathrm{insert}\ t\ k\ v)\rangle

\forall t.\ \langle \nodeboxrep\ p\ |\ \treerep\ t\rangle\ \texttt{lookup}(p, k)\ \langle v.\ \nodeboxrep\ p\ |\ \treerep\ t \land \mathrm{lookup}\ t\ k = v\rangle

\forall t.\ \langle \nodeboxrep\ p\ |\ \treerep\ t\rangle\ \texttt{delete}(p, k)\ \langle \nodeboxrep\ p\ |\ \treerep\ (\mathrm{delete}\ t\ k)\rangle
\end{mathpar}
In our case, insert, lookup, and delete are simple Gallina functions on a functional tree data structure. The details of $\nodeboxrep$ and $\treerep$ may vary by implementation, but we expect that $\nodeboxrep$ contains at least a pointer to the data structure, and $\treerep$ contains some ghost state linking the concrete state of the data structure to the abstract tree $t$.

In the following sections, we describe the construction of these predicates, and the proofs of the operations, for BST implementations based on hand-over-hand locking and lock-free atomic operations.

%look at some of the Iris papers in CPP, etc. for how we should describe the proofs, e.g. section 4 of Formal Verification of a Concurrent Bounded Queue in a Weak Memory Model, Mevel and Jourdan, ICFP 2021

%%%%%%%%%%%%%%%%%%%%%

\ignore{In the previous section, we showed that how to prove concurrent data-structure is thread safe, but not functionally correct. To prove the correctness, our threads need to be able to record the information about the actions they have performed on the shared state, instead of sealing all knowledge of the shared data structure inside the lock invariant. We can accomplish this with ghost variables, a simple form of auxiliary state. Aside from the \emph{permission} on shared resources held by each thread that we used in the safety proofs, the verification of correctness properties also involves the \emph{ghost state}. In VST, any Coq type can be used as ghost state, as long as we can describe what happens when two elements of that type are joined together. We can use own predicate in VST to represent ghost state assertion as follows: $\mathsf{own}\ g\ a\ \mathit{pp}$, where $g$ is a \emph{ghost name}, $a$ is the value associated with $g$ which can be of any type, and $\mathit{pp}$ is a separation logic predicate.}


%Linearizability is one of the most popular strong correctness condition for the most of %concurrent data-structure, which implies that every operation appears to take place atomically, %in some order, consistent with the real-time ordering of those operations. 
%In order to record the action each thread performed as a linear history, we will define global %invariants using the ghost state, which are similar to lock invariants but are not associated %with any particular memory location. Instead, a global invariant is true before and after every %step of a program, acting as a publicly accessible resource. A program instruction can use the %contents of global invariant if it can guarantee that no one will ever see an intermediate state %in which the invariant does not hold. 

\subsection{BST code}
\label{selflock}

\begin{figure}[htp]
\begin{lstlisting}[language = C, basicstyle=\small\ttfamily]
typedef struct tree {int key; void *value; struct tree_t *left, *right;} tree;
typedef struct tree_t {tree *t; lock_t *lock;} tree_t;
typedef struct tree_t **treebox;
\end{lstlisting}
\begin{subfigure}[t]{0.5\textwidth}
\begin{lstlisting}[language = C, basicstyle=\small\ttfamily, numbers=left]
void insert (treebox t, int x, void *value) {
  struct tree_t *tgt = *t;
  struct tree *p;
  void *l = tgt->lock;
  acquire(l);
  for(;;) {
    p = tgt->t;
    if (p==NULL) {
      tree_t *p1 = malloc(sizeof *tgt);
      tree_t *p2 = malloc(sizeof *tgt);
      p1->t = NULL;
      p2->t = NULL;
      lock_t *l1 = malloc(sizeof(lock_t));
      makelock(l1);
      p1->lock = l1;
      release2(l1);
      lock_t *l2 = malloc(sizeof(lock_t));
      makelock(l2);
      p2->lock = l2;
      release(l2);
      p = malloc(sizeof *p);
      tgt->t = p;
      p->key=x; p->value=value; p->left=p1; p->right=p2;
      release(l);
      return;
    } else {
      int y = p->key;
      if (x<y){
      	tgt = p->left;
        void *l_old = l;
        l = tgt->lock;
        acquire(l);
        release(l_old);
      } else if (y<x){
        tgt = p->right;
        void *l_old = l;
        l = tgt->lock;
        acquire(l);
        release(l_old);
      } else {
      	p->value=value;
        release(l);
      	return;
      }
    }
  }
} 
\end{lstlisting} 
\end{subfigure}\qquad
\begin{subfigure}[t]{0.4\textwidth}
 \begin{lstlisting}[language = C, basicstyle=\small\ttfamily]
void *lookup (treebox t, int x) {
  struct tree *p; void *v;
  struct tree_t *tgt;
  tgt = *t;
  void *l = tgt->lock;
  acquire(l);
  p = tgt->t;
  while (p != NULL) {
    int y = p->key;
    if (x<y){
      tgt = p->left;
      void *l_old = l;
      l = tgt->lock;
      acquire(l);
      p = tgt->t;
      release(l_old);
    } else if (y<x){
      tgt = p->right;
      void *l_old = l;
      l = tgt->lock;
      acquire(l);
      p = tgt->t;
      release2(l_old);
    } else {
      v = p->value;
      release(l);
      return v;
    }
  }
  release(l);
  return NULL;
}
\end{lstlisting}
\end{subfigure}
\caption{BST with hand-over-hand locking}
\label{bst-conc}
\end{figure}

\subsection{Fine-grained locking and atomicity}
\label{atomicity}

To prove that an operation on a data structure satisfies a logically atomic specification, we must show that there are no visible intermediate states of the operation, i.e., that other threads see the data structure as unchanged until the linearization point at which the operation takes effect. In traditional concurrent separation logics such as VST's~\cite{oraclesematic}, this is done by protecting the data structure with a single lock whose \emph{lock invariant} describes consistent states of the data structure. In modern separation logics such as Iris~\cite{iris} or FCSL~\cite{fcsl}, we can make a series of atomic modifications to the data structure without continuously holding a lock, as long as one modification can be designated the \emph{linearization point} at which the new state becomes public, and all prior changes are invisible to other threads. Fine-grained locking, in which the pieces of a data structure are each protected by a separate lock with a traditional lock invariant, requires us to synthesize these two approaches: we may make a series of non-atomic modifications to a part of the data structure as long as we hold its lock, but when we release the lock we need to ensure that either we have reached the linearization point, or our changes are invisible to other threads.

We accomplish this using a technique derived from unpublished work by Jung~\cite{ralf-convo} for treating the critical sections of locks as atomic operations. The key is to include in each lock invariant a piece of ghost state that represents the abstract state of the locked section. From the outside, the effect of the critical section is to atomically update that piece of ghost state, and all other changes are internal to the lock. These pieces of ghost state can then be composed to yield the abstract state of the entire data structure. In effect, this construction turns a traditional lock invariant into a \emph{lock variant} $\ell \lockvar R$, where $R$ is parameterized by a value that can be updated in the critical section, as long as it corresponds to a linearization point or invisible change to the abstract state of the data structure as a whole. This allows traditional lock invariants to interact with atomic shifts and be used to prove atomic specifications.

The construction of the lock variants is simple. We begin with a \emph{part-reference} ghost state, a common construction for sharing information between an invariant and the threads that act on it, with elements $\publichalf{a}$ (the current state $a$) and $\myhalf{\pi}{p}$ (partial information about the current state, annotated with a share $\pi$). When the share $\pi$ is 1, we know that $p = a$. (do we want to define this ourselves, or reference it somewhere? note also that this is what Iris calls an authoritative algebra) A lock variant with an assertion $R(a)$ is then defined as %notation
$$\ell \lockvar_\pi R \triangleq \ell \islock \exists a.\ R(a) * \myhalf{\pi}{a}$$ %eliding ghost names here
The share $\pi$ may be set to 1 if the lock's information about $a$ is always fully up to date, or a smaller share if it can become outdated due to operations on other parts of the data structure. Since $a$ is existentially quantified, a thread that changes the value of $a$ forgets it after releasing the lock (as required in a lock invariant), but it must have synchronized with a $\publichalf{a}$ held elsewhere (usually in a global invariant) that will remember the change. Thus, the ghost state acts as a bridge between the component lock invariant and the global abstract state of the data structure. %smaller example before we get into BST?

From the atomic rules of section~\ref{atomic}, we derive the following rules for accessing and modifying pieces of the global abstract state:
\begin{mathpar}
\inference[\textsf{sync\_commit}]{\forall a.\ R * P_p\ a \Rrightarrow \exists x_1.\ \mathsf{public\_half}(g, x_1) * \exists x_0',\,x_1'.\ (x_0, x_1) \leadsto (x_0', x_1')\ \land \\(\mathsf{my\_half}(g, \mathit{sh}, x_0') * \mathsf{public\_half}(g, x_1') \Rrightarrow \exists y.\ Q_p\ a\ y * R'\ y)}{\textsf{atomic\_shift}(P_p, E_i, E_o, Q_p, Q) * \textsf{my\_half}(g,sh,x_0) * R \Rrightarrow \mathsf{EX}\ y,\ Q\ y * R'\ y}

\inference[\textsf{sync\_rollback}]{\forall a.\ R * P_p\ a \Rrightarrow \exists x_1.\ \mathsf{public\_half}(g, x_1) * (\mathsf{public\_half}(g, x_1) \Rrightarrow P_p\ a * R')}{\begin{array}{c}\textsf{atomic\_shift}(P_p, E_i, E_o, Q_p, Q) * \textsf{my\_half}(g,sh,x_0) * R  \Rrightarrow \\\textsf{atomic\_shift}(P_p, E_i, E_o, Q_p, Q) * \textsf{my\_half}(g,sh,x_0) * R'\end{array}}
\end{mathpar}
A thread that holds $\myhalf{}{a}$ (i.e., is in the critical section of a lock with a lock variant) may interact with the abstract state $P_p$ held in an $\textsf{atomic\_shift}$, as long as the corresponding $\publichalf{}$ is part of the abstract state. It may either leave both halves as is and gain updated resources $R'$ (including, e.g., a snapshot of the current abstract state), or update both halves to a new state that satisfies the public postcondition $Q_p$, executing the linearization point and obtaining the final postcondition $Q$. Typically we will use one of these rules at the end of each critical section, to show that the changes made in the critical section either are invisible to other threads (\textsf{sync\_rollback}) or have fulfilled the linearization point (\textsf{sync\_commit}). We can also derive simpler rules for special cases, such as a version of \textsf{sync\_commit} for read-only operations that do not change the state of any component:

$$\inference[\textsf{sync\_commit\_same}]{\forall a.\ R * P_p\ a \Rrightarrow \exists x_1.\ \mathsf{public\_half}(g, x_1) * (\mathsf{my\_half}(g, \mathit{sh}, x_0) * \mathsf{public\_half}(g, x_1) \Rrightarrow \exists y.\ Q_p\ a\ y * R'\ y)}{\textsf{atomic\_shift}(P_p, E_i, E_o, Q_p, Q) * \textsf{my\_half}(g,sh,x_0) * R \Rrightarrow \mathsf{EX}\ y,\ Q\ y * R'\ y}$$

\subsection{Specification of the hand-over-hand BST}
%rewrite to use the above: this is the global state made up of components, etc.

To verify our tree implementation, we need to instantiate $\nodeboxrep$ (the resources held by each client thread) and $\treerep$ (the abstract state of the data structure), and show how they interact to access and update the state of the data structure for each call. In a lock-based implementation, $\nodeboxrep$ will be a pointer to the lock of the root node, and acquiring that lock will give the thread access to more of the data structure. As described above, our approach is to associate a piece of ghost state with each node in the tree, which will be shared between that node's lock and the abstract state in $\treerep$. We also need to make sure that our lock invariants support the hand-over-hand pattern.

\subsubsection{Key Ranges}
When we traverse the BST looking for a key $k$, we will reach either a node containing $k$, or an empty node where $k$ would appear if it was in the tree. To prove correctness of this procedure, we need ghost state that tracks where each key ``should appear'' in the current tree. As observed by Krishna et al.~\cite{krishna2017flow}, this can be done by associating each node with a lower and upper bound on the keys appearing in the subtree rooted at that node. We refer to the product of these bounds as a \emph{range}. The range of a node is inherited from its parent, based on the parent's key: if node $n$ has range $(l, r)$ and key $k$, then its left child has range $(l, k)$ and its right child has range $(k, r)$. Figure~\ref{range_bst} shows an example of a BST with each node labeled with its range, starting with $(-\infty, +\infty)$ at the root and propagated to the empty \emph{leaf} nodes. 
\begin{figure}[htb]
\centering
\includegraphics[width=70mm,scale=0.5]{../FIG/range_prop.png}
\caption{An example of BST with each node labeled with \emph{range}; lower and upper bound for a key}
\label{range_bst}
\end{figure}
At the leaves, these ranges partition the space of all possible keys. If we reach a leaf node with range $(a, b)$, then we know that keys between $a$ and $b$ 1) are not currently in the tree and 2) can correctly be inserted at this leaf.  For example, suppose we want to insert a key $38$ into the tree in Figure~\ref{range_bst}. The right child of the node with key 35 is a leaf with range $(35, 40)$, so it is guaranteed to be the right place to insert 38.

\subsubsection{Per-Node and Global Ghost State}
Importantly, the fact that the leaf ranges partition the space of possible keys remains true even if operations in other threads restructure the tree during our traversal. Furthermore, operations further up the tree can only \emph{increase} the range of nodes below them, so if we find a node whose range includes our key, we are guaranteed to have found the right place for it. This makes ranges ideal for use as ghost state: range information held by one thread will not be invalidated by other threads, and is sufficient to show correctness of BST operations. More precisely, the abstract state of a node in the tree consists of its range plus a representation of its contents: for a leaf node, $\mathsf{None}$, and for an internal node, $\mathsf{Some}$ of its current key, value, and the identifiers of its left and right children. This per-node abstract state serves as a bridge between the per-node locks of the implementation and the abstract state of the entire tree (the $\treerep$ predicate) in the specification.

The abstract state of a tree is a map from keys to values. The $\treerep$ predicate then describes the conditions under which a map $m$ is implemented by the ghost state of a tree. Roughly speaking, we should be able to gather the per-node ghost states into an abstract tree $t$ that implements the map $m$, in that each key-value pair in $m$ appears in one of the nodes of $t$. We formalize this by first defining the collection of $\mathsf{public\_half}$ assertions---i.e., the authoritative copies of the per-node ghost states---needed to form an abstract tree:
\begin{align*}
\mathsf{public}&\mathsf{\_halves}(t, g, (l, r)) \triangleq \mathsf{match}\ t\ \mathsf{with}\\
& |\ \mathsf{Leaf} \Rightarrow \mathsf{public\_half}_g\ ((l, r), \mathsf{None})\\
& |\ \mathsf{Node}\ (k, v, t_l, g_l, t_r, g_r) \Rightarrow \mathsf{public\_half}_g\ ((l, r), \mathsf{Some}\ (k, v, g_l, g_r)) * \mathsf{public\_halves}(t_l, g_l, (l, k)) * \mathsf{public\_halves}(t_r, g_r, (k, r))
\end{align*}
We recursively walk through the tree, starting from a node $g$ with range $(l, r)$, and collect the $\mathsf{public\_half}$ assertions of each node into a single assertion. We compute the range of each node's children as described above: if the key in the current node is $k$, then the left child has range $(l, k)$ and the right child has range $(k, r)$.

This collection of $\mathsf{public\_half}$ assertions can be combined with per-node lock variants to ensure that the nodes in an implementation actually form a valid tree. However, we also need to record the fact that each node in the implementation actually belongs to the tree $t$. We do this by augmenting $\mathsf{public\_halves}$ with a piece of ghost state $\mathsf{ghost\_nodes}(S)$ that records the set of all nodes in the tree, constructed so that each node can hold an $\mathsf{in\_tree}\ g$ assertion guaranteeing that $g \in S$. Then our final definition of $\treerep$ is:
$$\treerep(m, g) \triangleq \exists t.\ t \text{ implements } m \land \mathsf{public\_halves}(t, g, (-\infty, +\infty)) * \mathsf{ghost\_nodes}(\mathsf{node\_names}(t))$$
The range of the root node (named $g$) is $(-\infty, +\infty)$, and the $\mathsf{ghost\_nodes}$ assertion guarantees that if any thread or lock holds an assertion $\mathsf{in\_tree}\ g_i$, then $g_i$ is a node in the ghost tree $t$. Because we quantify over the abstract tree $t$, we can rearrange its nodes at any time, as long as it remains a well-formed tree with the same set of node names and key-value pairs. (We will take advantage of this property when verifying the \lstinline{delete} function.)

As described in section~\ref{atomicity}, we connect the per-node locks of our C implementation with the global abstract state of $\treerep$ by associating each node's lock with a lock variant assertion $\ell \islock_\pi R$, where $R$ is parameterized by the abstract state of the node (range + possible contents). We will fix the share $\pi$ to 1/2 so that the range in a node's lock can be out of date with respect to its $\mathsf{public\_half}$ (in particular, it may have grown due to rearrangements further up the tree). We then need to choose a variant $R$ describing the resources held by the lock for a given abstract state. The C implementation of a node is:
\begin{lstlisting}[language = C,numbers = none]
typedef struct tree {int key; void *value; struct tree_t *left, *right;} tree;
typedef struct tree_t {tree *t; lock_t *lock;} tree_t;
\end{lstlisting}
The node data of each \lstinline{tree} is wrapped in a \lstinline{tree_t} struct, and is only accessible when the lock in the \lstinline{lock} field is held. The lock variant for a node at location $p$ then needs to describe the contents of the \lstinline{t} field for each possible abstract state:
\begin{align*}
&\mathsf{match}\ c\ \mathsf{with}\\
&|\ \mathsf{None} \Rightarrow \texttt{t} \mapsto \texttt{NULL}\\
&|\ \mathsf{Some}\ (k, v, g_l, g_r) \Rightarrow \exists p_l, p_r.\ \texttt{t} \mapsto (k, v, p_l, p_r)
\end{align*}
We then combine this with the hand-over-hand invariant pattern of section~\ref{selflock}, giving us a final lock variant of:
\begin{align*}
\mathsf{node\_inv}((l, r), c) \triangleq \ &p.\texttt{lock} \lockvar_{\pi_1} \mathsf{node\_inv} * \mathsf{match}\ c\ \mathsf{with}\\
&|\ \mathsf{None} \Rightarrow \texttt{t} \mapsto \texttt{NULL}\\
&|\ \mathsf{Some}\ (k, v, g_l, g_r) \Rightarrow k \in (l, r) \land \exists p_l, p_r.\ \texttt{t} \mapsto (k, v, p_l, p_r) * \\&\qquad p_l.\texttt{lock} \lockvar_{\pi_2} \mathsf{node\_inv} * p_r.\texttt{lock} \lockvar_{\pi_2} \mathsf{node\_inv}
\end{align*}
While we do not know the ranges or contents of the child nodes, the lock-variant construction guarantees that they are consistent with the $\mathsf{public\_half}$ assertions of the global ghost state, and the hand-over-hand pattern allows us to acquire $p_l.\texttt{lock}$ or $p_r.\texttt{lock}$ and then release $p.\texttt{lock}$ without losing any shares of the lock assertions.

Now we have everything we need to specify the tree operations:
\begin{mathpar}
\forall m.\ \langle \nodeboxrep\ p\ |\ \treerep\ m\rangle\ \texttt{insert}(p, k, v)\ \langle \nodeboxrep\ p\ |\ \treerep\ (\mathrm{insert}\ m\ k\ v)\rangle

\forall m.\ \langle \nodeboxrep\ p\ |\ \treerep\ m\rangle\ \texttt{lookup}(p, k)\ \langle v.\ \nodeboxrep\ p\ |\ \treerep\ m \land \mathrm{lookup}\ m\ k = v\rangle

\forall m.\ \langle \nodeboxrep\ p\ |\ \treerep\ m\rangle\ \texttt{delete}(p, k)\ \langle \nodeboxrep\ p\ |\ \treerep\ (\mathrm{delete}\ m\ k)\rangle
\end{mathpar}
where $\treerep\ m$ asserts that global ghost state of the tree implements a map $m$, as described above, and $\nodeboxrep$ (the client's handle to the data structure) is simply a reference to the lock variant for the root node:
$$\nodeboxrep(b) \triangleq \exists p.\ b \mapsto p * p.\texttt{lock} \lockvar \mathsf{node\_inv}$$
Now we are prepared to prove that each of our BST functions satisfies its specification.

\subsection{Proofs: Insert and Lookup}
The basic verification style in VST is to divide proofs into two parts: proofs that the C implementations meet specifications that are Coq-level encodings of their behavior, and proofs that those encodings actually have the desired properties. In the single-threaded case, we might prove that some code implements a binary search tree written in Gallina, and then prove that that tree satisfies map axioms. Similarly, we divide our concurrency proofs into two parts: code-specific proofs that describe how the C code implements changes to per-node ghost state, and more abstract proofs describing how changes in local ghost state lead to the desired updates to the global state.

\subsubsection{Insert}
An outline of the C code for the insert function is shown in figure \ref{bst-conc}. When a thread inserts a key $k$ into a tree, it first crawls the tree to find the right position for $k$ using hand-over-hand locking. If it encounters a node with key $k$, then it simply changes the value at that node. Otherwise, it will eventually reach a leaf node, where it creates two new empty leaf nodes, inserts the key and value into the current node, and links the newly created leaf nodes to the current node. The atomic specification for insert method is $$\forall m.\ \langle \nodeboxrep\ p\ |\ \treerep\ m\rangle\ \texttt{insert}(p, k, v)\ \langle \nodeboxrep\ p\ |\ \treerep\ (\mathrm{insert}\ m\ k\ v)\rangle$$
The \lstinline{insert} function should atomically add the key-value pair $(k, v)$ to the map implemented by the BST at $p$.

The main loop of the \lstinline{insert} function traverses the tree to find the node where $k$ should be inserted. At the beginning of each iteration, we are at some node $n$ and hold the lock for that node, giving us the lock variant $\mathsf{node\_inv}((l, r), c)$ where $(l, r)$ is the range of keys in the subtree rooted at $n$. The loop invariant holds that $k \in (l, r)$, that is, the key $k$ always belongs in the subtree of the current node. This guarantees us that if we reach an empty leaf, that leaf is exactly the right place to add a node with key $k$.

The function has two possible linearization points: after line 23, where we finish adding a node $(k, v)$ to the tree, and after line 41, where we change the value of an existing node with key $k$ to $v$. In both cases, we use the \textsf{sync\_commit} rule to atomically update the abstract state of the data structure from $\treerep\ m$ to $\treerep (\mathrm{insert}\ m\ k\ v)$, by showing that the update to the tree implementation corresponds to a local change in the abstract tree that implements the mathematical $\mathsf{insert}$. In the first case, the local change is the insertion of $(k, v)$ at an empty leaf whose range includes $k$, and the addition of two new empty leaves as its children; in the second case, we simply change the value of an internal node whose key is already $k$. Our higher-level proofs, then, need to show that these two changes are both valid operations on ghost trees that yield the desired insertion in the global state.
  
\begin{figure}[htb]
\centering
\includegraphics[width=150mm,scale=0.5]{../FIG/extract_insert.png}
\caption{A visual depiction of the change in global state of BST during $\mathsf{insert(k,v)}$ operation }
\label{extract_insert}
\end{figure}
\begin{figure}[htb]
\centering
\includegraphics[width=150mm,scale=0.5]{../FIG/extract_insert_2.png}
\caption{A visual depiction of the change in global state of BST during $\mathsf{insert(k,v)}$ operation, where key $k$ already exists in the tree $t$ }
\label{extract_insert2}
\end{figure}

\paragraph{Changing the Global State} describe ``extract lemmas'' here---how much detail?

\subsubsection{Lookup}

The code for the $\mathsf{lookup}$ method is shown in Figure
\ref{lookupproof}. It takes the location of the root pointer and a key
as the arguments. A thread spans the tree to find a given key using
hand-over-hand locking mechanism. Once a thread finds the key in the
tree, it gets the value associated with that key, releases the current
node's lock, and returns the value.
The atomic specification for $\mathsf{lookup}$ is
$$\forall t.\ \langle \nodeboxrep\ p\ |\ \treerep\ t\rangle\ \texttt{lookup}(p, k)\ \langle v.\ \nodeboxrep\ p\ |\ \treerep\ t \land \mathrm{lookup}\ t\ k = v\rangle$$
The \texttt{lookup} function should atomically look up the value of the key $k$ in the tree at $p$.

As before, the key to the verification is the invariant for the main loop:
\begin{align*} &\mathsf{lookup\_inv}(b, x, \mathit{g\_root}, \mathit{range},\mathit{info}) \triangleq\ \exists\ \mathit{lock},\ \mathit{g\_current},\ \mathit{np},\ (x\in \mathit{range})\ \land \ \ghost{\mathsf{my\_half}(\mathit{range},\mathit{info})}{\mathit{g\_current}}\\& *\ R\ np\ * \mathsf{lock\_inv}(\mathit{lock},\mathit{lsh2},R')\ *\ \nodeboxrep(b,\mathit{g\_root})\ *\ \mathsf{atomic\_shift} (P_p,E_i,E_o,Q_p,Q) \end{align*}
where $P_p$ and $Q_p$ are $\treerep(g\_root, t)$ and $(v =
M[k])\ \wedge\ \treerep(g\_root, t)$ respectively. The proof steps for
the $\texttt{lookup}$ verification are similar to the steps
used in $\texttt{insert}$ verification, with a few differences which we
discuss below.

Figure \ref{lookupproof} shows the $\mathsf{lookup}$ function
with separation logic annotations. The proof starts with
$\nodeboxrep$ and $\mathsf{atomic\_shift}$ assertions as the
precondition and follows the same approach as the $\mathsf{insert}$
proof for the verification of loop body. Once we find the target key
(the last $\mathsf{else}$ clause in the code), we need
to confirm that the value present in the tree corresponds with the value we would find if we looked up the key in the current abstract state. We accomplish this by opening the global
invariant encoded in the $\mathsf{atomic\_shift}$, and proving that
lookup satisfies the public postcondition $\mathsf{Q\_p}$ with the help
of the $\mathsf{sync\_commit\_same}$ lemma described in section
\ref{atomicity}. This is the linearization point of the
$\mathsf{lookup}$ operation and must be done before releasing the
current node's lock. When we move into the left or right sub-tree,
we need to establish $\mathsf{lookup\_inv}$ at the end of the $\mathsf{if}$
or $\mathsf{else\ if}$ clause. Here, we need to show that the key we
are searching for is still in the range of our new node, so we use
$\mathsf{sync\_rollback}$ to extract the bound of the left/right
node encoded as the ghost state in the public precondition
($\treerep(M, g, g\_root)$).

A critical difference from $\texttt{insert}$ is that the
$\texttt{lookup}$ method does not change the shape of the tree. With the
help of $\texttt{sync\_commit\_same}$, we need no longer the
heavyweight $\emph{extract}$ lemma but instead a simpler
$\emph{ramif}$ lemma to locate the current node in the global
invariants:
\begin{verbatim}
Lemma ghost_tree_rep_public_half_ramif: forall tg g_root r_root g_in,
Ensembles.In (find_ghost_set tg g_root) g_in -> ghost_tree_rep tg g_root r_root |-- 
EX r: node_info, !! (range_info_in_tree r r_root tg) && (public_half g_in r * 
(public_half g_in r -* ghost_tree_rep tg g_root r_root)).
\end{verbatim}

\begin{figure}[htp]
\begin{subfigure}[t]{1\textwidth}
 $$\left\{\begin{array}{l} \nodeboxrep(b,g\_root)\ *\ \mathsf{atomic\_shift}(P_p,E_i,E_o,Q_p,Q)\end{array}\right\}$$
\begin{lstlisting}[language = C,  numbers = none]
void *lookup (treebox t, int x) {
  struct tree *p; void *v;  struct tree_t *tgt;
  tgt = *t;  void *l = tgt->lock;
  acquire(l);  p = tgt->t;
 \end{lstlisting}  
 $$\left\{\begin{array}{l} \ghost{\mathsf{my\_half}((-\infty,+\infty),info)}{g\_root}\ *\ R\ b\ *\ \mathsf{lock\_inv}(l,lsh2,R')\ *\ \\
 \nodeboxrep(b,g\_root)\ *\ \mathsf{atomic\_shift}(P_p,E_i,E_o,Q_p,Q)\end{array}\right\} \Rrightarrow \left\{\begin{array}{l} lookup\_inv \end{array}\right\}$$ 
  \begin{lstlisting}[language = C, numbers = none]
    while (p!=NULL) {
       \end{lstlisting}   
   $$\left\{\begin{array}{l} lookup\_inv \end{array}\right\} \triangleq \left\{\begin{array}{l}(x\in range)\land \ghost{\mathsf{my\_half}(range,info)}{g\_current}*\ R\ np\ *\\\mathsf{lock\_inv}(lock,lsh2,R')\ *\ \nodeboxrep(b,g\_root)\ *\ \mathsf{atomic\_shift}(P_p,E_i,E_o,Q_p,Q)\end{array}\right\}$$
      \begin{lstlisting}[language = C,  numbers = none]
    if (x<y){
      tgt=p->left;
      ....
    }else if (y<x){
      tgt=p->right;
     ....
    }else {
    v = p->value;
           \end{lstlisting} 
  $$\left\{\begin{array}{l} \ghost{\mathsf{my\_half}(range,info)}{g\_current}*\ R\ np\ *\mathsf{lock\_inv}(lock,lsh2,R')\ *\ \\\nodeboxrep(b,g\_root)\ *\ \mathsf{atomic\_shift}(P_p,E_i,E_o,Q_p,Q)\end{array}\right\} \Rrightarrow{\textbf{sync\_commit\_same}}$$
$$\left\{\begin{array}{l} \ghost{\mathsf{my\_half}(range,info)}{g\_current}*\ R\ np\ *\mathsf{lock\_inv}(lock,lsh2,R')\ *\ \nodeboxrep(b,g\_root)\ *\ Q\end{array}\right\}$$
        \begin{lstlisting}[language = C,  numbers = none]
      release2(l);
         \end{lstlisting}
       $$\left\{\begin{array}{l} \nodeboxrep(b,g\_root)\ *\ Q\end{array}\right\}$$
         \begin{lstlisting}[language = C, numbers = none]
       return v;} }
  release2(l);  return NULL;  }
 \end{lstlisting} 
\end{subfigure}
\caption{The $\texttt{lookup}$ function annotated with separation logic specification}
\label{lookupproof}
\end{figure} 

\subsection{Delete}

The code for the delete method is shown in ??. It takes the location of the root pointer
and a key as the arguments. A thread traverses the tree using hand-over-hand locking,
until the thread finds the key to be deleted. To remove the key, the tree is changed 
through an operation called pushdown left such that the node to be deleted points to an empty leaf
right child. To achieve that, the thread sets the right child's left child as the 
new right child of the to-be-deleted node and moves the right child's right child as 
the new parent of the to-be-deleted node. This operation is repeated until the right
child of the to-be-deleted node is an empty leaf node. Then, the thread will delete
the node and set the delete node's parent pointer to the left child of the deleted node.

The atomic specification for delete method can be written as follows:
$$\forall t.\ \langle \nodeboxrep(p,g,g\_root)\ |\ \treerep(t,g)\rangle $$ 
$$\texttt{delete}(p,k)$$
$$\langle \nodeboxrep(p,g,g\_root)\ |\ \treerep(\texttt{delete}(t, k),g)\rangle $$

The delete method is unique compared to insert and lookup because the pushdown left 
operation can change the \textit{public} half range of more than one nodes. In addition,
the pushdown left operation is one of the main reasons why the ghost tree of the binary
search tree is not just a ``copy" of the pure tree: the functional model of pushdown\_left
is unable to account for the change of deleted node's parent's pointer from pointing
at the deleted node the to the deleted node's right child.



\usetikzlibrary{positioning}

\forestset{
   lab/.style={
        label={[anchor=west, scale=0.75] north east:#1},
    },
}
\begin{forest}
for tree={
    grow=south,
    circle, draw, minimum size=3ex, inner sep=1pt,
    s sep=3mm
        }
    % my label/.style={
        % label={[anchor=south west] north east:#1},
    % },
    [, phantom, for children={fit=band}, s sep+=20mm,
         before drawing tree={%
          tikz+={%
            \node (a) [inner sep=0pt, fit=(!1) (!1L) (!1F)] {};
            \node (b) [inner sep=0pt, fit=(!l) (!lL) (!lF)] {};
            \node [anchor=center] at ($(a.east)!1/2!(b.west)$) {$\longrightarrow\quad$};
          },
        },
        [ 30, tikz={\node[right=0pt of .north east, scale=0.75]  {$(-\infty,\infty)$};}
            [25, tikz={\node[left=0pt of .north west, scale=0.75]  {$(-\infty,30)$};}]
            [75, tikz={\node[right=0pt of .north east, scale=0.75]  {$(30,\infty)$};}
                [40, tikz={\node[left=0pt of .north west, scale=0.75]  {$(30,75)$};}
                    [35, tikz={\node[left=0pt of .north west, scale=0.75]  {$(30,40)$};}]
                    [55, tikz={\node[right=0pt of .north east, scale=0.75]  {$(40,75)$};}
                        [50, tikz={\node[left=0pt of .north west, scale=0.75]  {$(40,55)$};}]
                        [60, tikz={\node[right=0pt of .north east, scale=0.75]  {$(55,75)$};}]
                    ]
                ]
                [80, tikz={\node[right=0pt of .north east, scale=0.75]  {$(75,\infty)$};}]
            ]
        ]
        [ 30, tikz={\node[right=0pt of .north east, scale=0.75]  {$(-\infty,\infty)$};}
            [25, tikz={\node[left=0pt of .north west, scale=0.75]  {$(-\infty,30)$};}]
            [75, tikz={\node[right=0pt of .north east, scale=0.75]  {$(30,\infty)$};}
                [55, tikz={\node[left=0pt of .north west, scale=0.75]  {$(30,75)$};}
                    [40, tikz={\node[left=0pt of .north west, scale=0.75]  {$(30,55)$};}
                        [35, tikz={\node[left=0pt of .north west, scale=0.75]  {$(40,35)$};}]
                        [50, tikz={\node[right=0pt of .north east, scale=0.75]  {$(40,55)$};}]
                    ]
                    [60, tikz={\node[right=0pt of .north east, scale=0.75]  {$(55,75)$};}]
                ]
                [80, tikz={\node[right=0pt of .north east, scale=0.75]  {$(75,\infty)$};}]
            ]
        ]
        [ 30, tikz={\node[right=0pt of .north east, scale=0.75]  {$(-\infty,\infty)$};}
            [25, tikz={\node[left=0pt of .north west, scale=0.75]  {$(-\infty,30)$};}]
            [75, tikz={\node[right=0pt of .north east, scale=0.75]  {$(30,\infty)$};}
                [55, tikz={\node[left=0pt of .north west, scale=0.75]  {$(30,75)$};}
                    [50, tikz={\node[left=0pt of .north west, scale=0.75]  {$(30,55)$};}
                        [40, tikz={\node[left=0pt of .north west, scale=0.75]  {$(30,50)$};}
                            [35, tikz={\node[left=0pt of .north west, scale=0.75]  {$(30,35)$};}]
                            [,no edge, draw=none]
                        ]
                        [,no edge, draw=none]
                    ]
                    [60, tikz={\node[right=0pt of .north east, scale=0.75]  {$(55,75)$};}]
                ]
                [80, tikz={\node[right=0pt of .north east, scale=0.75]  {$(75,\infty)$};}]
            ]
        ]
        [ 30, tikz={\node[right=0pt of .north east, scale=0.75]  {$(-\infty,\infty)$};}
            [25, tikz={\node[left=0pt of .north west, scale=0.75]  {$(-\infty,30)$};}]
            [75, tikz={\node[right=0pt of .north east, scale=0.75]  {$(30,\infty)$};}
                [55, tikz={\node[left=0pt of .north west, scale=0.75]  {$(30,75)$};}
                    [50, tikz={\node[left=0pt of .north west, scale=0.75]  {$(30,55)$};}
                        [35, tikz={\node[left=0pt of .north west, scale=0.75]  {$(30,35)$};}]
                        [,no edge, draw=none]
                    ]
                    [60, tikz={\node[right=0pt of .north east, scale=0.75]  {$(55,75)$};}]
                ]
                [80, tikz={\node[right=0pt of .north east, scale=0.75]  {$(75,\infty)$};}]
            ]
        ]
    ]
\end{forest}

\subsubsection{delete}

Similar with insert, delete starts by acquiring the root node lock, so that the thread
can access the information inside the lock invariant of the root node. Then, we prove
the while loop by showing that the precondition satisfies delete\_inv and the 
loop body preserves the loop invariant. The first two cases are similar to insert and
lookup in which the thread finds the target node, traversing by hand-over-hand locking.
Once the target node is located, the thread will call pushdown\_left and return after.
Using the specification of pushdown\_left, we show that the post-condition of 
pushdown\_left implies the loop invariant. Note that before going into pushdown\_left,
the thread is holding the lock to the target node and will return to the delete
method without holding any.

\subsubsection{pushdown\_left}

The proof to pushdown\_left is the key step of proving the delete method. 
First, we show that the precondition of pushdown\_left satisfies the precondition
of the loop invariant, which includes the assertion that the thread is holding the 
lock to the deleted node (i.e. the information inside the lock invariant is accessible)
and an atomic\_shift. Then, the thread accesses that information to acquire a second 
lock to the right child of the deleted node. Due to the hand-over-hand locking 
mechanism this will not cause a deadlock since the thread has already acquired the 
lock to the deleted node. Next, we prove that the action of deleting the node,
with sync\_commit by opening the global invariant and removing the relevant 
ghost names (the target node and its right sentinel node), satisfies the loop
invariant and the postcondition of pushdown\_left.

The second part of pushdown\_left is proving that the turn\_left operation satisfies
the loop invariant. Using a variant of the sync\_rollback rule, we show that the 
turn\_left operation preserves the BST, apart from changes in the ranges of two nodes,
the target node and its right child, and information about the nodes in those two nodes.
To satisfy the structure of the ranges, we only need to prove that the new range for
the target node is encompasses the old range of both nodes. This will imply that
the range of the target node's old parent includes the target node's right child 
new range as the right child becomes the new parent (and the old parent points to 
the right child).

One key step of the proof is proving that two ghost trees are equivalent if the union
of its ghost nodes are equal and the ghost tree is sorted. This allows the global invariant
to be preserved during the turn\_left operation in which no nodes were actually changed
except for the structure of the tree.


\section{Lock-Free BST}
We want to prove that a lock-free BST implementation satisfies the same specification as our hand-over-hand implementation. Unfortunately, provably-correct deletion in a lock-free setting is a research topic in itself (cite?), so we begin with a lock-free BST that only supports insert and lookup. Once again, we want to prove
\begin{mathpar}
\forall t.\ \langle \nodeboxrep\ p\ |\ \treerep\ t\rangle\ \texttt{insert}(p, k, v)\ \langle \nodeboxrep\ p\ |\ \treerep\ (\mathrm{insert}\ t\ k\ v)\rangle

\forall t.\ \langle \nodeboxrep\ p\ |\ \treerep\ t\rangle\ \texttt{lookup}(p, k)\ \langle v.\ \nodeboxrep\ p\ |\ \treerep\ t \land \mathrm{lookup}\ t\ k = v\rangle
\end{mathpar}
though the precise definitions of $\nodeboxrep$ and $\treerep$ will differ. %something about how the fact that the specs are the same really comes across to a client -- and should we prove a client?

\section{Using the Specifications}
client and client proofs

\section{Related Work}
\label{related}
Our work is based on the concurrent separation logic of VST in the style of Iris \cite{higherorderghoststate} and the logical atomicity from TaDA logic  \cite{tada}. The notion of the \emph{lower} and \emph{upper} bound is taken from the flow interface paper \cite{krishna2017flow}. Our main technical contributions are the verification of two different implementation of binary search tree (using fine-grained locking and lock-free technique) with respect to the same abstract specification, and first c-level mechanized verification of concurrent search-based data structure (i.e. BST). Most of the other concurrent separation logic (CSL)-based verification works are on toy languages, while VST lets us use the same logic on real C programs.  VeriFast~\cite{verifast-conc} also operates on C code, albeit without a full formal semantics of C.

Gotsman and Yang \cite{gotsman} is one of the earliest work on concurrent separation logic. They introduced the program logic to reason locally about the heap-manipulating program with the notion of dynamic ownership of heap parts by unbounded number of locks and threads, and shown the verification of singly-linked list with fine-grained locking. Xiong et al. \cite{Xiong2017Abstract} have demonstrated the verification of ConcurrentSkipListMap from java.util.concurrent library using the recent advances in fine-grained concurrency reasoning. Their work is mainly based on the abstract atomicity from TaDA logic, and give two modular specifications for concurrent maps: one specification focus on the entire map structure which is suitable for verifying implementation, and another specification focus on the key-value pairs which appropriate for verifying clients. We use the same idea of atomicity (though implemented in Iris) in our work. 

Krishna et al. \cite{krishna2017flow} have presented the proof technique for concurrent search structure templates based on the flow framework and the Iris separation logic, and verified the implementation of concurrent B-tree, hash tables, and linked lists based on the templates. Their work is closely related to our work; we took some inspiration from them in building our ghost state. But, their proofs are on a toy language rather than real C code.

\section{Conclusion}
\label{conclusion}

%% Bibliography
\bibliography{../sources}
\end{document}
