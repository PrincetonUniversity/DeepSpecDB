@ARTICLE{moore,  author={R. R. {Schaller}},  journal={IEEE Spectrum},   title={Moore's law: past, present and future},   year={1997},  volume={34},  number={6},  pages={52-59},  doi={10.1109/6.591665}}


@book{plfcc,
author = {Appel, Andrew W. and Dockins, Robert and Hobor, Aquinas and Beringer, Lennart and Dodds, Josiah and Stewart, Gordon and Blazy, Sandrine and Leroy, Xavier},
title = {Program Logics for Certified Compilers},
year = {2014},
isbn = {110704801X},
publisher = {Cambridge University Press},
address = {USA},
abstract = {Separation Logic is the twenty-first-century variant of Hoare Logic that permits verification of pointer-manipulating programs. This book covers practical and theoretical aspects of Separation Logic at a level accessible to beginning graduate students interested in software verification. On the practical side it offers an introduction to verification in Hoare and Separation logics, simple case studies for toy languages, and the Verifiable C program logic for the C programming language. On the theoretical side it presents separation algebras as models of separation logics; step-indexed models of higher-order logical features for higher-order programs; indirection theory for constructing step-indexed separation algebras; tree-shares as models for shared ownership; and the semantic construction (and soundness proof) of Verifiable C. In addition, the book covers several aspects of the CompCert verified C compiler, and its connection to foundationally verified software analysis tools. All constructions and proofs are made rigorous and accessible in the Coq developments of the open-source Verified Software Toolchain.}
}

@INPROCEEDINGS{seplogic,  author={J. C. {Reynolds}},  booktitle={Proceedings 17th Annual IEEE Symposium on Logic in Computer Science},   title={Separation logic: a logic for shared mutable data structures},   year={2002},  volume={},  number={},  pages={55-74},  doi={10.1109/LICS.2002.1029817}}

@article{hoare,
author = {Hoare, C. A. R.},
title = {An Axiomatic Basis for Computer Programming},
year = {1969},
issue_date = {Oct. 1969},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {12},
number = {10},
issn = {0001-0782},
url = {https://doi.org/10.1145/363235.363259},
doi = {10.1145/363235.363259},
abstract = {In this paper an attempt is made to explore the logical foundations of computer programming by use of techniques which were first applied in the study of geometry and have later been extended to other branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which can be used in proofs of the properties of computer programs. Examples are given of such axioms and rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important advantage, both theoretical and practical, may follow from a pursuance of these topics.},
journal = {Commun. ACM},
month = oct,
pages = {576–580},
numpages = {5},
keywords = {programming language design, machine-independent programming, formal language definition, theory of programming' proofs of programs, axiomatic method, program documentation}
}

@InProceedings{oraclesematic,
author="Hobor, Aquinas
and Appel, Andrew W.
and Nardelli, Francesco Zappa",
editor="Drossopoulou, Sophia",
title="Oracle Semantics for Concurrent Separation Logic",
booktitle="Programming Languages and Systems",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="353--367",
isbn="978-3-540-78739-6"
}


@inproceedings{fuminfli,
author = {Fu, Ming and Li, Yong and Feng, Xinyu and Shao, Zhong and Zhang, Yu},
title = {Reasoning about Optimistic Concurrency Using a Program Logic for History},
year = {2010},
isbn = {3642153747},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {Optimistic concurrency algorithms provide good performance for parallel programs but they are extremely hard to reason about. Program logics such as concurrent separation logic and rely-guarantee reasoning can be used to verify these algorithms, but they make heavy uses of history variables which may obscure the high-level intuition underlying the design of these algorithms. In this paper, we propose a novel program logic that uses invariants on history traces to reason about optimistic concurrency algorithms. We use past tense temporal operators in our assertions to specify execution histories. Our logic supports modular program specifications with history information by providing separation over both space (program states) and time. We verify Michael's non-blocking stack algorithm and show that the intuition behind such algorithm can be naturally captured using trace invariants.},
booktitle = {Proceedings of the 21st International Conference on Concurrency Theory},
pages = {388–402},
numpages = {15},
location = {Paris, France},
series = {CONCUR'10}
}


@article{higherorderghoststate,
author = {Jung, Ralf and Krebbers, Robbert and Birkedal, Lars and Dreyer, Derek},
title = {Higher-Order Ghost State},
year = {2016},
issue_date = {September 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/3022670.2951943},
doi = {10.1145/3022670.2951943}
}

@article{csl,
title = {Resources, concurrency, and local reasoning},
journal = {Theoretical Computer Science},
volume = {375},
number = {1},
pages = {271-307},
year = {2007},
note = {Festschrift for John C. Reynolds’s 70th birthday},
issn = {0304-3975},
doi = {https://doi.org/10.1016/j.tcs.2006.12.035},
url = {https://www.sciencedirect.com/science/article/pii/S030439750600925X},
author = {Peter W. O’Hearn},
keywords = {Concurrency, Logics of programs, Separation logic},
abstract = {In this paper we show how a resource-oriented logic, separation logic, can be used to reason about the usage of resources in concurrent programs.}
}

@inproceedings{vafeiadis,
author = {Vafeiadis, Viktor and Parkinson, Matthew},
title = {A Marriage of Rely/Guarantee and Separation Logic},
year = {2007},
isbn = {3540744061},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {In the quest for tractable methods for reasoning about concurrent algorithms both rely/guarantee logic and separation logic have made great advances. They both seek to tame, or control, the complexity of concurrent interactions, but neither is the ultimate approach. Relyguarantee copes naturally with interference, but its specifications are complex because they describe the entire state. Conversely separation logic has difficulty dealing with interference, but its specifications are simpler because they describe only the relevant state that the program accesses.We propose a combined system which marries the two approaches. We can describe interference naturally (using a relation as in rely/guarantee), and where there is no interference, we can reason locally (as in separation logic). We demonstrate the advantages of the combined approach by verifying a lock-coupling list algorithm, which actually disposes/frees removed nodes.},
booktitle = {Proceedings of the 18th International Conference on Concurrency Theory},
pages = {256–271},
numpages = {16},
location = {Lisbon, Portugal},
series = {CONCUR'07}
}

@InProceedings{tada,
author="da Rocha Pinto, Pedro
and Dinsdale-Young, Thomas
and Gardner, Philippa",
editor="Jones, Richard",
title="{TaDA}: A Logic for Time and Data Abstraction",
booktitle="ECOOP 2014 -- Object-Oriented Programming",
year="2014",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="207--231",
abstract="To avoid data races, concurrent operations should either be at distinct times or on distinct data. Atomicity is the abstraction that an operation takes effect at a single, discrete instant in time, with linearisability being a well-known correctness condition which asserts that concurrent operations appear to behave atomically. Disjointness is the abstraction that operations act on distinct data resource, with concurrent separation logics enabling reasoning about threads that appear to operate independently on disjoint resources.",
isbn="978-3-662-44202-9"
}
@inproceedings{concurrentabstractpredicates,
author = {Dinsdale-Young, Thomas and Dodds, Mike and Gardner, Philippa and Parkinson, Matthew J. and Vafeiadis, Viktor},
title = {Concurrent Abstract Predicates},
year = {2010},
isbn = {3642141064},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {Abstraction is key to understanding and reasoning about large computer systems. Abstraction is simple to achieve if the relevant data structures are disjoint, but rather difficult when they are partially shared, as is often the case for concurrent modules. We present a program logic for reasoning abstractly about data structures that provides a fiction of disjointness and permits compositional reasoning. The internal details of a module are completely hidden from the client by concurrent abstract predicates. We reason about a module's implementation using separation logic with permissions, and provide abstract specifications for use by client programs using concurrent abstract predicates. We illustrate our abstract reasoning by building two implementations of a lock module on top of hardware instructions, and two implementations of a concurrent set module on top of the lock module.},
booktitle = {Proceedings of the 24th European Conference on Object-Oriented Programming},
pages = {504–528},
numpages = {25},
location = {Maribor, Slovenia},
series = {ECOOP'10}
}

@article{krishna2017flow,
author = {Krishna, Siddharth and Shasha, Dennis and Wies, Thomas},
title = {Go with the Flow: Compositional Abstractions for Concurrent Data Structures},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158125},
doi = {10.1145/3158125},
abstract = {Concurrent separation logics have helped to significantly simplify correctness proofs for concurrent data structures. However, a recurring problem in such proofs is that data structure abstractions that work well in the sequential setting are much harder to reason about in a concurrent setting due to complex sharing and overlays. To solve this problem, we propose a novel approach to abstracting regions in the heap by encoding the data structure invariant into a local condition on each individual node. This condition may depend on a quantity associated with the node that is computed as a fixpoint over the entire heap graph. We refer to this quantity as a flow. Flows can encode both structural properties of the heap (e.g. the reachable nodes from the root form a tree) as well as data invariants (e.g. sortedness). We then introduce the notion of a flow interface, which expresses the relies and guarantees that a heap region imposes on its context to maintain the local flow invariant with respect to the global heap. Our main technical result is that this notion leads to a new semantic model of separation logic. In this model, flow interfaces provide a general abstraction mechanism for describing complex data structures. This abstraction mechanism admits proof rules that generalize over a wide variety of data structures. To demonstrate the versatility of our approach, we show how to extend the logic RGSep with flow interfaces. We have used this new logic to prove linearizability and memory safety of nontrivial concurrent data structures. In particular, we obtain parametric linearizability proofs for concurrent dictionary algorithms that abstract from the details of the underlying data structure representation. These proofs cannot be easily expressed using the abstraction mechanisms provided by existing separation logics.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {37},
numpages = {31},
keywords = {flow interfaces, memory safety, linearizability, separation algebra}
}

@inproceedings{feng,
author = {Feng, Xinyu and Ferreira, Rodrigo and Shao, Zhong},
title = {On the Relationship between Concurrent Separation Logic and Assume-Guarantee Reasoning},
year = {2007},
isbn = {9783540713142},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {We study the relationship between Concurrent Separation Logic (CSL) and the assume-guarantee (A-G) method (a.k.a. rely-guarantee method). We show in three steps that CSL can be treated as a specialization of the A-G method for well-synchronized concurrent programs. First, we present an A-G based program logic for a low-level language with built-in locking primitives. Then we extend the program logic with explicit separation of "private data" and "shared data", which provides better memory modularity. Finally, we show that CSL (adapted for the low-level language) can be viewed as a specialization of the extended A-G logic by enforcing the invariant that "shared resources are well-formed outside of critical regions". This work can also be viewed as a different approach (from Brookes') to proving the soundness of CSL: our CSL inference rules are proved as lemmas in the A-G based logic, whose soundness is established following the syntactic approach to proving soundness of type systems.},
booktitle = {Proceedings of the 16th European Symposium on Programming},
pages = {173–188},
numpages = {16},
location = {Braga, Portugal},
series = {ESOP'07}
}

@article{GPS-RCU,
 author = {Tassarotti, Joseph and Dreyer, Derek and Vafeiadis, Viktor},
 title = {Verifying Read-copy-update in a Logic for Weak Memory},
 booktitle = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
 series = {PLDI '15},
 year = {2015},
 isbn = {978-1-4503-3468-6},
 location = {Portland, OR, USA},
 pages = {110--120},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/2737924.2737992},
 doi = {10.1145/2737924.2737992},
 acmid = {2737992},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {C/C++, Concurrency, Program logic, RCU, Separation logic, Weak memory models},
} 

@misc{ralf-convo,
  author = {Jung, Ralf},
  year = {2020},
  howpublished = {personal communication}
}

@InProceedings{gotsman,
author="Gotsman, Alexey
and Berdine, Josh
and Cook, Byron
and Rinetzky, Noam
and Sagiv, Mooly",
editor="Shao, Zhong",
title="Local Reasoning for Storable Locks and Threads",
booktitle="Programming Languages and Systems",
year="2007",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="19--37",
abstract="We present a resource oriented program logic that is able to reason about concurrent heap-manipulating programs with unbounded numbers of dynamically-allocated locks and threads. The logic is inspired by concurrent separation logic, but handles these more realistic concurrency primitives. We demonstrate that the proposed logic allows local reasoning about programs for which there exists a notion of dynamic ownership of heap parts by locks and threads.",
isbn="978-3-540-76637-7"
}

@inproceedings{Xiong2017Abstract,
  author = {Xiong, Shale and {da Rocha Pinto}, Pedro and Ntzik, Gian and Gardner, Philippa},
  title = {Abstract Specifications for Concurrent Maps},
  booktitle = {Proceedings of the 26\textsuperscript{th} European Symposium on Programming ({ESOP'17})},
  year = {2017},
  editor = {Yang, Hongseok},
  volume = {10201},
  series = {Lecture Notes in Computer Science},
  pages = {964--990},
  month = apr,
  publisher = {Springer},
  abstract = {Despite recent advances in reasoning about concurrent data structure libraries, the largest implementations in java.util.concurrent have yet to be verified. The key issue lies in the development of modular specifications, which provide clear logical boundaries between clients and implementations. A solution is to use recent advances in fine-grained concurrency reasoning, in particular the introduction of abstract atomicity to concurrent separation logic reasoning. We present two specifications of concurrent maps, both providing the clear boundaries we seek. We show that these specifications are equivalent, in that they can be built from each other. We show how we can verify client programs, such as a concurrent set and a producer-consumer client. We also give a substantial first proof that the main operations of ConcurrentSkipListMap in java.util.concurrent satisfy the map specification. This work demonstrates that we now have the technology to verify the largest implementations in java.util.concurrent.},
  doi = {10.1007/978-3-662-54434-1_36}
}


@article{bayer1977,
author = {Bayer, R. and Schkolnick, M.},
title = {Concurrency of Operations on B-Trees},
year = {1977},
issue_date = {March     1977},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
volume = {9},
number = {1},
issn = {0001-5903},
url = {https://doi.org/10.1007/BF00263762},
doi = {10.1007/BF00263762},
abstract = {Concurrent operations on B-trees pose the problem of insuring that each operation can be carried out without interfering with other operations being performed simultaneously by other users. This problem can become critical if these structures are being used to support access paths, like indexes, to data base systems. In this case, serializing access to one of these indexes can create an unacceptable bottleneck for the entire system. Thus, there is a need for locking protocols that can assure integrity for each access while at the same time providing a maximum possible degree of concurrency. Another feature required from these protocols is that they be deadlock free, since the cost to resolve a deadlock may be high.Recently, there has been some questioning on whether B-tree structures can support concurrent operations. In this paper, we examine the problem of concurrent access to B-trees. We present a deadlock free solution which can be tuned to specific requirements. An analysis is presented which allows the selection of parameters so as to satisfy these requirements.The solution presented here uses simple locking protocols. Thus, we conclude that B-trees can be used advantageously in a multi-user environment.},
journal = {Acta Inf.},
month = mar,
pages = {1–21},
numpages = {21}
}

@inproceedings{iris,
  author    = {Ralf Jung and
               David Swasey and
               Filip Sieczkowski and
               Kasper Svendsen and
               Aaron Turon and
               Lars Birkedal and
               Derek Dreyer},
  title     = {Iris: Monoids and Invariants as an Orthogonal Basis for Concurrent
               Reasoning},
  booktitle = {Proceedings of the 42nd Annual {ACM} {SIGPLAN-SIGACT} Symposium on
               Principles of Programming Languages, {POPL} 2015, Mumbai, India, January
               15-17, 2015},
  pages     = {637--650},
  publisher = {{ACM}},
  year      = {2015},
  url       = {https://doi.org/10.1145/2676726.2676980},
  doi       = {10.1145/2676726.2676980},
  timestamp = {Thu, 14 Oct 2021 09:53:20 +0200},
  biburl    = {https://dblp.org/rec/conf/popl/JungSSSTBD15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{fcsl,
  author    = {Ilya Sergey and
               Aleksandar Nanevski and
               Anindya Banerjee},
  title     = {Specifying and Verifying Concurrent Algorithms with Histories and
               Subjectivity},
  booktitle = {Programming Languages and Systems - 24th European Symposium on Programming,
               {ESOP} 2015, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2015, London, UK, April 11-18, 2015.
               Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {9032},
  pages     = {333--358},
  publisher = {Springer},
  year      = {2015},
  url       = {https://doi.org/10.1007/978-3-662-46669-8\_14},
  doi       = {10.1007/978-3-662-46669-8\_14},
  timestamp = {Tue, 20 Aug 2019 15:27:49 +0200},
  biburl    = {https://dblp.org/rec/conf/esop/SergeyNB15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{verifast-conc,
author = {Jacobs, Bart and Piessens, Frank},
title = {Expressive Modular Fine-Grained Concurrency Specification},
year = {2011},
isbn = {9781450304900},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1926385.1926417},
doi = {10.1145/1926385.1926417},
abstract = {Compared to coarse-grained external synchronization of operations on data structures shared between concurrent threads, fine-grained, internal synchronization can offer stronger progress guarantees and better performance. However, fully specifying operations that perform internal synchronization modularly is a hard, open problem. The state of the art approaches, based on linearizability or on concurrent abstract predicates, have important limitations on the expressiveness of specifications. Linearizability does not support ownership transfer, and the concurrent abstract predicates-based specification approach requires hardcoding a particular usage protocol. In this paper, we propose a novel approach that lifts these limitations and enables fully general specification of fine-grained concurrent data structures. The basic idea is that clients pass the ghost code required to instantiate an operation's specification for a specific client scenario into the operation in a simple form of higher-order programming.We machine-checked the theory of the paper using the Coq proof assistant. Furthermore, we implemented the approach in our program verifier VeriFast and used it to verify two challenging fine-grained concurrent data structures from the literature: a multiple-compare-and-swap algorithm and a lock-coupling list.},
booktitle = {Proceedings of the 38th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {271–282},
numpages = {12},
keywords = {fine-grained concurrency, separation logic},
location = {Austin, Texas, USA},
series = {POPL '11}
}

@inproceedings{gps,
  author    = {Aaron Turon and
               Viktor Vafeiadis and
               Derek Dreyer},
  title     = {{GPS:} navigating weak memory with ghosts, protocols, and separation},
  booktitle = {Proceedings of the 2014 {ACM} International Conference on Object Oriented
               Programming Systems Languages {\&} Applications, {OOPSLA} 2014,
               part of {SPLASH} 2014, Portland, OR, USA, October 20-24, 2014},
  pages     = {691--707},
  publisher = {{ACM}},
  year      = {2014},
  url       = {https://doi.org/10.1145/2660193.2660243},
  doi       = {10.1145/2660193.2660243},
  timestamp = {Thu, 24 Jun 2021 16:19:30 +0200},
  biburl    = {https://dblp.org/rec/conf/oopsla/TuronVD14.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@unpublished{atomic-syncer,
  author = "Zhen Zhang",
  title  = "iris-atomic",
  note   = "https://gitlab.mpi-sws.org/FP/iris-atomic/-/raw/master/docs/atomic.pdf",
  month  = "December",
  year   = "2016",
  annote = ""
}

@inproceedings{caresl,
author = {Turon, Aaron and Dreyer, Derek and Birkedal, Lars},
title = {Unifying Refinement and Hoare-Style Reasoning in a Logic for Higher-Order Concurrency},
year = {2013},
isbn = {9781450323260},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2500365.2500600},
doi = {10.1145/2500365.2500600},
abstract = {Modular programming and modular verification go hand in hand, but most existing logics for concurrency ignore two crucial forms of modularity: *higher-order functions*, which are essential for building reusable components, and *granularity abstraction*, a key technique for hiding the intricacies of fine-grained concurrent data structures from the clients of those data structures. In this paper, we present CaReSL, the first logic to support the use of granularity abstraction for modular verification of higher-order concurrent programs. After motivating the features of CaReSL through a variety of illustrative examples, we demonstrate its effectiveness by using it to tackle a significant case study: the first formal proof of (partial) correctness for Hendler et al.'s "flat combining" algorithm.},
booktitle = {Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming},
pages = {377–390},
numpages = {14},
keywords = {separation logic, kripke logical relations, contextual refinement, fine-grained concurrency, higher-order functions},
location = {Boston, Massachusetts, USA},
series = {ICFP '13}
}

@article{tada-live,
  author = {D'Osualdo, Emanuele and Farzan, Azadeh and Gardner, Philippa and Sutherland, Julian},
  title = {{TaDA Live}: Compositional Reasoning for Termination of Fine-grained
              Concurrent Programs},
  journal = {ACM Transactions on Programming Languages and Systems (TOPLAS).},
  year = {2021},
  abstract = {We present TaDA Live, a concurrent separation logic for reasoning compositionally about the termination of
  blocking fine-grained concurrent programs. The crucial challenge is how to deal with abstract atomic blocking:
  that is, abstract atomic operations that have blocking behaviour arising from busy-waiting patterns as found in,
  for example, fine-grained spin locks. Our fundamental innovation is with the design of abstract specifications
  that capture this blocking behaviour as liveness assumptions on the environment. We design a logic that
  can reason about the termination of clients which use such operations without breaking their abstraction
  boundaries, and the correctness of the implementations of the operations with respect to their abstract
  specifications. We introduce a novel semantic model using layered subjective obligations to express liveness
  invariants, and a proof system that is sound with respect to the model. The subtlety of our specifications and
  reasoning is illustrated using several case studies.}
}

@article{compcert,
author = {Leroy, Xavier},
title = {Formal Verification of a Realistic Compiler},
year = {2009},
issue_date = {July 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/1538788.1538814},
doi = {10.1145/1538788.1538814},
abstract = {This paper reports on the development and formal verification (proof of semantic preservation) of CompCert, a compiler from Clight (a large subset of the C programming language) to PowerPC assembly code, using the Coq proof assistant both for programming the compiler and for proving its correctness. Such a verified compiler is useful in the context of critical software and its formal verification: the verification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
journal = {Commun. ACM},
month = {jul},
pages = {107–115},
numpages = {9}
}

@inproceedings{templates,
author = {Krishna, Siddharth and Patel, Nisarg and Shasha, Dennis and Wies, Thomas},
title = {Verifying Concurrent Search Structure Templates},
year = {2020},
isbn = {9781450376136},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3385412.3386029},
doi = {10.1145/3385412.3386029},
abstract = {Concurrent separation logics have had great success reasoning about concurrent data structures. This success stems from their application of modularity on multiple levels, leading to proofs that are decomposed according to program structure, program state, and individual threads. Despite these advances, it remains difficult to achieve proof reuse across different data structure implementations. For the large class of search structures, we demonstrate how one can achieve further proof modularity by decoupling the proof of thread safety from the proof of structural integrity. We base our work on the template algorithms of Shasha and Goodman that dictate how threads interact but abstract from the concrete layout of nodes in memory. Building on the recently proposed flow framework of compositional abstractions and the separation logic Iris, we show how to prove correctness of template algorithms, and how to instantiate them to obtain multiple verified implementations. We demonstrate our approach by mechanizing the proofs of three concurrent search structure templates, based on link, give-up, and lock-coupling synchronization, and deriving verified implementations based on B-trees, hash tables, and linked lists. These case studies include algorithms used in real-world file systems and databases, which have been beyond the capability of prior automated or mechanized verification techniques. In addition, our approach reduces proof complexity and is able to achieve significant proof reuse.},
booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {181–196},
numpages = {16},
keywords = {template-based verification, flow framework, separation logic, concurrent data structures},
location = {London, UK},
series = {PLDI 2020}
}

@article{rustbelt-relaxed,
author = {Dang, Hoang-Hai and Jourdan, Jacques-Henri and Kaiser, Jan-Oliver and Dreyer, Derek},
title = {{RustBelt} Meets Relaxed Memory},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371102},
doi = {10.1145/3371102},
abstract = {The Rust programming language supports safe systems programming by means of a strong ownership-tracking type system. In their prior work on RustBelt, Jung et al. began the task of setting Rust’s safety claims on a more rigorous formal foundation. Specifically, they used Iris, a Coq-based separation logic framework, to build a machine-checked proof of semantic soundness for a λ-calculus model of Rust, as well as for a number of widely-used Rust libraries that internally employ unsafe language features. However, they also made the significant simplifying assumption that the language is sequentially consistent. In this paper, we adapt RustBelt to account for the relaxed-memory operations that concurrent Rust libraries actually use, in the process uncovering a data race in the Arc library. We focus on the most interesting technical problem: how to reason about resource reclamation under relaxed memory, using a logical construction we call synchronized ghost state.},
journal = {Proc. ACM Program. Lang.},
month = {Dec},
articleno = {34},
numpages = {29},
keywords = {Iris, semantic soundness, relaxed memory models, Rust}
}

@techreport{cpm,
  author      = " Cuellar, Santiago and Giannarakis, Nick and Madiot, Jean-Marie and Mansky, William and Beringer, Lennart and Cao, Qinxiang and Appel, Andrew ",
  title       = "Compiler Correctness for Concurrency: from concurrent separation logic to shared-memory assembly language",
  institution = "Princeton University",
  year        = "2020"
}

@InProceedings{verifast,
author="Jacobs, Bart
and Smans, Jan
and Philippaerts, Pieter
and Vogels, Fr{\'e}d{\'e}ric
and Penninckx, Willem
and Piessens, Frank",
editor="Bobaru, Mihaela
and Havelund, Klaus
and Holzmann, Gerard J.
and Joshi, Rajeev",
title="{VeriFast}: A Powerful, Sound, Predictable, Fast Verifier for {C} and {Java}",
booktitle="NASA Formal Methods",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="41--55",
abstract="VeriFast is a prototype verification tool for single-threaded and multithreaded C and Java programs. In this paper, we first describe the basic symbolic execution approach in some formal detail. Then we zoom in on two technical aspects: the approach to permission accounting, including fractional permissions, precise predicates, and counting permissions; and the approach to lemma function termination in the presence of dynamically-bound lemma function calls. Finally, we describe three ongoing efforts: application to JavaCard programs, integration of shape analysis, and application to Linux device drivers.",
isbn="978-3-642-20398-5"
}

