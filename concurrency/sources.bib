@ARTICLE{moore,  author={R. R. {Schaller}},  journal={IEEE Spectrum},   title={Moore's law: past, present and future},   year={1997},  volume={34},  number={6},  pages={52-59},  doi={10.1109/6.591665}}


@book{plcc,
author = {Appel, Andrew W. and Dockins, Robert and Hobor, Aquinas and Beringer, Lennart and Dodds, Josiah and Stewart, Gordon and Blazy, Sandrine and Leroy, Xavier},
title = {Program Logics for Certified Compilers},
year = {2014},
isbn = {110704801X},
publisher = {Cambridge University Press},
place = {Cambridge},
abstract = {Separation Logic is the twenty-first-century variant of Hoare Logic that permits verification of pointer-manipulating programs. This book covers practical and theoretical aspects of Separation Logic at a level accessible to beginning graduate students interested in software verification. On the practical side it offers an introduction to verification in Hoare and Separation logics, simple case studies for toy languages, and the Verifiable C program logic for the C programming language. On the theoretical side it presents separation algebras as models of separation logics; step-indexed models of higher-order logical features for higher-order programs; indirection theory for constructing step-indexed separation algebras; tree-shares as models for shared ownership; and the semantic construction (and soundness proof) of Verifiable C. In addition, the book covers several aspects of the CompCert verified C compiler, and its connection to foundationally verified software analysis tools. All constructions and proofs are made rigorous and accessible in the Coq developments of the open-source Verified Software Toolchain.}
}

@INPROCEEDINGS{seplogic,  author={J. C. {Reynolds}},  booktitle={Proceedings 17th Annual IEEE Symposium on Logic in Computer Science},   title={Separation logic: a logic for shared mutable data structures},   year={2002},  volume={},  number={},  pages={55-74},  doi={10.1109/LICS.2002.1029817}}

@article{hoare,
author = {Hoare, C. A. R.},
title = {An Axiomatic Basis for Computer Programming},
year = {1969},
issue_date = {Oct. 1969},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {12},
number = {10},
issn = {0001-0782},
url = {https://doi.org/10.1145/363235.363259},
doi = {10.1145/363235.363259},
abstract = {In this paper an attempt is made to explore the logical foundations of computer programming by use of techniques which were first applied in the study of geometry and have later been extended to other branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which can be used in proofs of the properties of computer programs. Examples are given of such axioms and rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important advantage, both theoretical and practical, may follow from a pursuance of these topics.},
journal = {Commun. ACM},
month = oct,
pages = {576–580},
numpages = {5},
keywords = {programming language design, machine-independent programming, formal language definition, theory of programming' proofs of programs, axiomatic method, program documentation}
}

@InProceedings{oraclesematic,
author="Hobor, Aquinas
and Appel, Andrew W.
and Nardelli, Francesco Zappa",
editor="Drossopoulou, Sophia",
title="Oracle Semantics for Concurrent Separation Logic",
booktitle="Programming Languages and Systems",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="353--367",
isbn="978-3-540-78739-6"
}


@inproceedings{fuminfli,
author = {Fu, Ming and Li, Yong and Feng, Xinyu and Shao, Zhong and Zhang, Yu},
title = {Reasoning about Optimistic Concurrency Using a Program Logic for History},
year = {2010},
isbn = {3642153747},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {Optimistic concurrency algorithms provide good performance for parallel programs but they are extremely hard to reason about. Program logics such as concurrent separation logic and rely-guarantee reasoning can be used to verify these algorithms, but they make heavy uses of history variables which may obscure the high-level intuition underlying the design of these algorithms. In this paper, we propose a novel program logic that uses invariants on history traces to reason about optimistic concurrency algorithms. We use past tense temporal operators in our assertions to specify execution histories. Our logic supports modular program specifications with history information by providing separation over both space (program states) and time. We verify Michael's non-blocking stack algorithm and show that the intuition behind such algorithm can be naturally captured using trace invariants.},
booktitle = {Proceedings of the 21st International Conference on Concurrency Theory},
pages = {388–402},
numpages = {15},
location = {Paris, France},
series = {CONCUR'10}
}


@article{higherorderghoststate,
author = {Jung, Ralf and Krebbers, Robbert and Birkedal, Lars and Dreyer, Derek},
title = {Higher-Order Ghost State},
year = {2016},
issue_date = {September 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/3022670.2951943},
doi = {10.1145/3022670.2951943}
}

@article{csl,
title = {Resources, concurrency, and local reasoning},
journal = {Theoretical Computer Science},
volume = {375},
number = {1},
pages = {271-307},
year = {2007},
note = {Festschrift for John C. Reynolds’s 70th birthday},
issn = {0304-3975},
doi = {https://doi.org/10.1016/j.tcs.2006.12.035},
url = {https://www.sciencedirect.com/science/article/pii/S030439750600925X},
author = {Peter W. O’Hearn},
keywords = {Concurrency, Logics of programs, Separation logic},
abstract = {In this paper we show how a resource-oriented logic, separation logic, can be used to reason about the usage of resources in concurrent programs.}
}

@inproceedings{vafeiadis,
author = {Vafeiadis, Viktor and Parkinson, Matthew},
title = {A Marriage of Rely/Guarantee and Separation Logic},
year = {2007},
isbn = {3540744061},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {In the quest for tractable methods for reasoning about concurrent algorithms both rely/guarantee logic and separation logic have made great advances. They both seek to tame, or control, the complexity of concurrent interactions, but neither is the ultimate approach. Relyguarantee copes naturally with interference, but its specifications are complex because they describe the entire state. Conversely separation logic has difficulty dealing with interference, but its specifications are simpler because they describe only the relevant state that the program accesses.We propose a combined system which marries the two approaches. We can describe interference naturally (using a relation as in rely/guarantee), and where there is no interference, we can reason locally (as in separation logic). We demonstrate the advantages of the combined approach by verifying a lock-coupling list algorithm, which actually disposes/frees removed nodes.},
booktitle = {Proceedings of the 18th International Conference on Concurrency Theory},
pages = {256–271},
numpages = {16},
location = {Lisbon, Portugal},
series = {CONCUR'07}
}

@InProceedings{tada,
author="da Rocha Pinto, Pedro
and Dinsdale-Young, Thomas
and Gardner, Philippa",
editor="Jones, Richard",
title="{TaDA}: A Logic for Time and Data Abstraction",
booktitle="ECOOP 2014 -- Object-Oriented Programming",
year="2014",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="207--231",
abstract="To avoid data races, concurrent operations should either be at distinct times or on distinct data. Atomicity is the abstraction that an operation takes effect at a single, discrete instant in time, with linearisability being a well-known correctness condition which asserts that concurrent operations appear to behave atomically. Disjointness is the abstraction that operations act on distinct data resource, with concurrent separation logics enabling reasoning about threads that appear to operate independently on disjoint resources.",
isbn="978-3-662-44202-9"
}
@inproceedings{concurrentabstractpredicates,
author = {Dinsdale-Young, Thomas and Dodds, Mike and Gardner, Philippa and Parkinson, Matthew J. and Vafeiadis, Viktor},
title = {Concurrent Abstract Predicates},
year = {2010},
isbn = {3642141064},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {Abstraction is key to understanding and reasoning about large computer systems. Abstraction is simple to achieve if the relevant data structures are disjoint, but rather difficult when they are partially shared, as is often the case for concurrent modules. We present a program logic for reasoning abstractly about data structures that provides a fiction of disjointness and permits compositional reasoning. The internal details of a module are completely hidden from the client by concurrent abstract predicates. We reason about a module's implementation using separation logic with permissions, and provide abstract specifications for use by client programs using concurrent abstract predicates. We illustrate our abstract reasoning by building two implementations of a lock module on top of hardware instructions, and two implementations of a concurrent set module on top of the lock module.},
booktitle = {Proceedings of the 24th European Conference on Object-Oriented Programming},
pages = {504–528},
numpages = {25},
location = {Maribor, Slovenia},
series = {ECOOP'10}
}

@article{krishna2017flow,
author = {Krishna, Siddharth and Shasha, Dennis and Wies, Thomas},
title = {Go with the Flow: Compositional Abstractions for Concurrent Data Structures},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158125},
doi = {10.1145/3158125},
abstract = {Concurrent separation logics have helped to significantly simplify correctness proofs for concurrent data structures. However, a recurring problem in such proofs is that data structure abstractions that work well in the sequential setting are much harder to reason about in a concurrent setting due to complex sharing and overlays. To solve this problem, we propose a novel approach to abstracting regions in the heap by encoding the data structure invariant into a local condition on each individual node. This condition may depend on a quantity associated with the node that is computed as a fixpoint over the entire heap graph. We refer to this quantity as a flow. Flows can encode both structural properties of the heap (e.g. the reachable nodes from the root form a tree) as well as data invariants (e.g. sortedness). We then introduce the notion of a flow interface, which expresses the relies and guarantees that a heap region imposes on its context to maintain the local flow invariant with respect to the global heap. Our main technical result is that this notion leads to a new semantic model of separation logic. In this model, flow interfaces provide a general abstraction mechanism for describing complex data structures. This abstraction mechanism admits proof rules that generalize over a wide variety of data structures. To demonstrate the versatility of our approach, we show how to extend the logic RGSep with flow interfaces. We have used this new logic to prove linearizability and memory safety of nontrivial concurrent data structures. In particular, we obtain parametric linearizability proofs for concurrent dictionary algorithms that abstract from the details of the underlying data structure representation. These proofs cannot be easily expressed using the abstraction mechanisms provided by existing separation logics.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {37},
numpages = {31},
keywords = {flow interfaces, memory safety, linearizability, separation algebra}
}

@inproceedings{feng,
author = {Feng, Xinyu and Ferreira, Rodrigo and Shao, Zhong},
title = {On the Relationship between Concurrent Separation Logic and Assume-Guarantee Reasoning},
year = {2007},
isbn = {9783540713142},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {We study the relationship between Concurrent Separation Logic (CSL) and the assume-guarantee (A-G) method (a.k.a. rely-guarantee method). We show in three steps that CSL can be treated as a specialization of the A-G method for well-synchronized concurrent programs. First, we present an A-G based program logic for a low-level language with built-in locking primitives. Then we extend the program logic with explicit separation of "private data" and "shared data", which provides better memory modularity. Finally, we show that CSL (adapted for the low-level language) can be viewed as a specialization of the extended A-G logic by enforcing the invariant that "shared resources are well-formed outside of critical regions". This work can also be viewed as a different approach (from Brookes') to proving the soundness of CSL: our CSL inference rules are proved as lemmas in the A-G based logic, whose soundness is established following the syntactic approach to proving soundness of type systems.},
booktitle = {Proceedings of the 16th European Symposium on Programming},
pages = {173–188},
numpages = {16},
location = {Braga, Portugal},
series = {ESOP'07}
}

@article{GPS-RCU,
 author = {Tassarotti, Joseph and Dreyer, Derek and Vafeiadis, Viktor},
 title = {Verifying Read-copy-update in a Logic for Weak Memory},
 booktitle = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
 series = {PLDI '15},
 year = {2015},
 isbn = {978-1-4503-3468-6},
 location = {Portland, OR, USA},
 pages = {110--120},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/2737924.2737992},
 doi = {10.1145/2737924.2737992},
 acmid = {2737992},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {C/C++, Concurrency, Program logic, RCU, Separation logic, Weak memory models},
} 

@misc{ralf-convo,
  author = {Jung, Ralf},
  year = {2020},
  howpublished = {personal communication}
}

@InProceedings{gotsman,
author="Gotsman, Alexey
and Berdine, Josh
and Cook, Byron
and Rinetzky, Noam
and Sagiv, Mooly",
editor="Shao, Zhong",
title="Local Reasoning for Storable Locks and Threads",
booktitle="Programming Languages and Systems",
year="2007",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="19--37",
abstract="We present a resource oriented program logic that is able to reason about concurrent heap-manipulating programs with unbounded numbers of dynamically-allocated locks and threads. The logic is inspired by concurrent separation logic, but handles these more realistic concurrency primitives. We demonstrate that the proposed logic allows local reasoning about programs for which there exists a notion of dynamic ownership of heap parts by locks and threads.",
isbn="978-3-540-76637-7"
}

@inproceedings{Xiong2017Abstract,
  author = {Xiong, Shale and {da Rocha Pinto}, Pedro and Ntzik, Gian and Gardner, Philippa},
  title = {Abstract Specifications for Concurrent Maps},
  booktitle = {Proceedings of the 26\textsuperscript{th} European Symposium on Programming ({ESOP'17})},
  year = {2017},
  editor = {Yang, Hongseok},
  volume = {10201},
  series = {Lecture Notes in Computer Science},
  pages = {964--990},
  month = apr,
  publisher = {Springer},
  abstract = {Despite recent advances in reasoning about concurrent data structure libraries, the largest implementations in java.util.concurrent have yet to be verified. The key issue lies in the development of modular specifications, which provide clear logical boundaries between clients and implementations. A solution is to use recent advances in fine-grained concurrency reasoning, in particular the introduction of abstract atomicity to concurrent separation logic reasoning. We present two specifications of concurrent maps, both providing the clear boundaries we seek. We show that these specifications are equivalent, in that they can be built from each other. We show how we can verify client programs, such as a concurrent set and a producer-consumer client. We also give a substantial first proof that the main operations of ConcurrentSkipListMap in java.util.concurrent satisfy the map specification. This work demonstrates that we now have the technology to verify the largest implementations in java.util.concurrent.},
  doi = {10.1007/978-3-662-54434-1_36}
}


@article{bayer1977,
author = {Bayer, R. and Schkolnick, M.},
title = {Concurrency of Operations on B-Trees},
year = {1977},
issue_date = {March     1977},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
volume = {9},
number = {1},
issn = {0001-5903},
url = {https://doi.org/10.1007/BF00263762},
doi = {10.1007/BF00263762},
abstract = {Concurrent operations on B-trees pose the problem of insuring that each operation can be carried out without interfering with other operations being performed simultaneously by other users. This problem can become critical if these structures are being used to support access paths, like indexes, to data base systems. In this case, serializing access to one of these indexes can create an unacceptable bottleneck for the entire system. Thus, there is a need for locking protocols that can assure integrity for each access while at the same time providing a maximum possible degree of concurrency. Another feature required from these protocols is that they be deadlock free, since the cost to resolve a deadlock may be high.Recently, there has been some questioning on whether B-tree structures can support concurrent operations. In this paper, we examine the problem of concurrent access to B-trees. We present a deadlock free solution which can be tuned to specific requirements. An analysis is presented which allows the selection of parameters so as to satisfy these requirements.The solution presented here uses simple locking protocols. Thus, we conclude that B-trees can be used advantageously in a multi-user environment.},
journal = {Acta Inf.},
month = mar,
pages = {1–21},
numpages = {21}
}

@inproceedings{iris,
  author    = {Ralf Jung and
               David Swasey and
               Filip Sieczkowski and
               Kasper Svendsen and
               Aaron Turon and
               Lars Birkedal and
               Derek Dreyer},
  title     = {Iris: Monoids and Invariants as an Orthogonal Basis for Concurrent
               Reasoning},
  booktitle = {Proceedings of the 42nd Annual {ACM} {SIGPLAN-SIGACT} Symposium on
               Principles of Programming Languages, {POPL} 2015, Mumbai, India, January
               15-17, 2015},
  pages     = {637--650},
  publisher = {{ACM}},
  year      = {2015},
  url       = {https://doi.org/10.1145/2676726.2676980},
  doi       = {10.1145/2676726.2676980},
  timestamp = {Thu, 14 Oct 2021 09:53:20 +0200},
  biburl    = {https://dblp.org/rec/conf/popl/JungSSSTBD15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{fcsl,
  author    = {Ilya Sergey and
               Aleksandar Nanevski and
               Anindya Banerjee},
  title     = {Specifying and Verifying Concurrent Algorithms with Histories and
               Subjectivity},
  booktitle = {Programming Languages and Systems - 24th European Symposium on Programming,
               {ESOP} 2015, Held as Part of the European Joint Conferences on Theory
               and Practice of Software, {ETAPS} 2015, London, UK, April 11-18, 2015.
               Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {9032},
  pages     = {333--358},
  publisher = {Springer},
  year      = {2015},
  url       = {https://doi.org/10.1007/978-3-662-46669-8\_14},
  doi       = {10.1007/978-3-662-46669-8\_14},
  timestamp = {Tue, 20 Aug 2019 15:27:49 +0200},
  biburl    = {https://dblp.org/rec/conf/esop/SergeyNB15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{verifast-conc,
author = {Jacobs, Bart and Piessens, Frank},
title = {Expressive Modular Fine-Grained Concurrency Specification},
year = {2011},
isbn = {9781450304900},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1926385.1926417},
doi = {10.1145/1926385.1926417},
abstract = {Compared to coarse-grained external synchronization of operations on data structures shared between concurrent threads, fine-grained, internal synchronization can offer stronger progress guarantees and better performance. However, fully specifying operations that perform internal synchronization modularly is a hard, open problem. The state of the art approaches, based on linearizability or on concurrent abstract predicates, have important limitations on the expressiveness of specifications. Linearizability does not support ownership transfer, and the concurrent abstract predicates-based specification approach requires hardcoding a particular usage protocol. In this paper, we propose a novel approach that lifts these limitations and enables fully general specification of fine-grained concurrent data structures. The basic idea is that clients pass the ghost code required to instantiate an operation's specification for a specific client scenario into the operation in a simple form of higher-order programming.We machine-checked the theory of the paper using the Coq proof assistant. Furthermore, we implemented the approach in our program verifier VeriFast and used it to verify two challenging fine-grained concurrent data structures from the literature: a multiple-compare-and-swap algorithm and a lock-coupling list.},
booktitle = {Proceedings of the 38th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {271–282},
numpages = {12},
keywords = {fine-grained concurrency, separation logic},
location = {Austin, Texas, USA},
series = {POPL '11}
}

@inproceedings{gps,
  author    = {Aaron Turon and
               Viktor Vafeiadis and
               Derek Dreyer},
  title     = {{GPS:} Navigating Weak Memory with Ghosts, Protocols, and Separation},
  booktitle = {Proceedings of the 2014 {ACM} International Conference on Object Oriented
               Programming Systems Languages {\&} Applications, {OOPSLA} 2014,
               part of {SPLASH} 2014, Portland, OR, USA, October 20-24, 2014},
  pages     = {691--707},
  publisher = {{ACM}},
  year      = {2014},
  url       = {https://doi.org/10.1145/2660193.2660243},
  doi       = {10.1145/2660193.2660243},
  timestamp = {Thu, 24 Jun 2021 16:19:30 +0200},
  biburl    = {https://dblp.org/rec/conf/oopsla/TuronVD14.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@unpublished{atomic-syncer,
  author = "Zhen Zhang",
  title  = "iris-atomic",
  note   = "https://gitlab.mpi-sws.org/FP/iris-atomic/-/raw/master/docs/atomic.pdf",
  month  = "December",
  year   = "2016",
  annote = ""
}

@inproceedings{caresl,
author = {Turon, Aaron and Dreyer, Derek and Birkedal, Lars},
title = {Unifying Refinement and Hoare-Style Reasoning in a Logic for Higher-Order Concurrency},
year = {2013},
isbn = {9781450323260},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2500365.2500600},
doi = {10.1145/2500365.2500600},
abstract = {Modular programming and modular verification go hand in hand, but most existing logics for concurrency ignore two crucial forms of modularity: *higher-order functions*, which are essential for building reusable components, and *granularity abstraction*, a key technique for hiding the intricacies of fine-grained concurrent data structures from the clients of those data structures. In this paper, we present CaReSL, the first logic to support the use of granularity abstraction for modular verification of higher-order concurrent programs. After motivating the features of CaReSL through a variety of illustrative examples, we demonstrate its effectiveness by using it to tackle a significant case study: the first formal proof of (partial) correctness for Hendler et al.'s "flat combining" algorithm.},
booktitle = {Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming},
pages = {377–390},
numpages = {14},
keywords = {separation logic, kripke logical relations, contextual refinement, fine-grained concurrency, higher-order functions},
location = {Boston, Massachusetts, USA},
series = {ICFP '13}
}

@article{tada-live,
  author = {D'Osualdo, Emanuele and Farzan, Azadeh and Gardner, Philippa and Sutherland, Julian},
  title = {{TaDA Live}: Compositional Reasoning for Termination of Fine-grained
              Concurrent Programs},
  journal = {ACM Transactions on Programming Languages and Systems (TOPLAS).},
  year = {2021},
  abstract = {We present TaDA Live, a concurrent separation logic for reasoning compositionally about the termination of
  blocking fine-grained concurrent programs. The crucial challenge is how to deal with abstract atomic blocking:
  that is, abstract atomic operations that have blocking behaviour arising from busy-waiting patterns as found in,
  for example, fine-grained spin locks. Our fundamental innovation is with the design of abstract specifications
  that capture this blocking behaviour as liveness assumptions on the environment. We design a logic that
  can reason about the termination of clients which use such operations without breaking their abstraction
  boundaries, and the correctness of the implementations of the operations with respect to their abstract
  specifications. We introduce a novel semantic model using layered subjective obligations to express liveness
  invariants, and a proof system that is sound with respect to the model. The subtlety of our specifications and
  reasoning is illustrated using several case studies.}
}

@article{compcert,
author = {Leroy, Xavier},
title = {Formal Verification of a Realistic Compiler},
year = {2009},
issue_date = {July 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/1538788.1538814},
doi = {10.1145/1538788.1538814},
abstract = {This paper reports on the development and formal verification (proof of semantic preservation) of CompCert, a compiler from Clight (a large subset of the C programming language) to PowerPC assembly code, using the Coq proof assistant both for programming the compiler and for proving its correctness. Such a verified compiler is useful in the context of critical software and its formal verification: the verification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
journal = {Commun. ACM},
month = {jul},
pages = {107–115},
numpages = {9}
}

@inproceedings{templates,
author = {Krishna, Siddharth and Patel, Nisarg and Shasha, Dennis and Wies, Thomas},
title = {Verifying Concurrent Search Structure Templates},
year = {2020},
isbn = {9781450376136},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3385412.3386029},
doi = {10.1145/3385412.3386029},
abstract = {Concurrent separation logics have had great success reasoning about concurrent data structures. This success stems from their application of modularity on multiple levels, leading to proofs that are decomposed according to program structure, program state, and individual threads. Despite these advances, it remains difficult to achieve proof reuse across different data structure implementations. For the large class of search structures, we demonstrate how one can achieve further proof modularity by decoupling the proof of thread safety from the proof of structural integrity. We base our work on the template algorithms of Shasha and Goodman that dictate how threads interact but abstract from the concrete layout of nodes in memory. Building on the recently proposed flow framework of compositional abstractions and the separation logic Iris, we show how to prove correctness of template algorithms, and how to instantiate them to obtain multiple verified implementations. We demonstrate our approach by mechanizing the proofs of three concurrent search structure templates, based on link, give-up, and lock-coupling synchronization, and deriving verified implementations based on B-trees, hash tables, and linked lists. These case studies include algorithms used in real-world file systems and databases, which have been beyond the capability of prior automated or mechanized verification techniques. In addition, our approach reduces proof complexity and is able to achieve significant proof reuse.},
booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {181–196},
numpages = {16},
keywords = {template-based verification, flow framework, separation logic, concurrent data structures},
location = {London, UK},
series = {PLDI 2020}
}

@article{rustbelt,
author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
title = {RustBelt: Securing the Foundations of the Rust Programming Language},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158154},
doi = {10.1145/3158154},
abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {66},
numpages = {34},
keywords = {separation logic, Rust, concurrency, type systems, logical relations}
}

@article{rustbelt-relaxed,
author = {Dang, Hoang-Hai and Jourdan, Jacques-Henri and Kaiser, Jan-Oliver and Dreyer, Derek},
title = {{RustBelt} Meets Relaxed Memory},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371102},
doi = {10.1145/3371102},
abstract = {The Rust programming language supports safe systems programming by means of a strong ownership-tracking type system. In their prior work on RustBelt, Jung et al. began the task of setting Rust’s safety claims on a more rigorous formal foundation. Specifically, they used Iris, a Coq-based separation logic framework, to build a machine-checked proof of semantic soundness for a λ-calculus model of Rust, as well as for a number of widely-used Rust libraries that internally employ unsafe language features. However, they also made the significant simplifying assumption that the language is sequentially consistent. In this paper, we adapt RustBelt to account for the relaxed-memory operations that concurrent Rust libraries actually use, in the process uncovering a data race in the Arc library. We focus on the most interesting technical problem: how to reason about resource reclamation under relaxed memory, using a logical construction we call synchronized ghost state.},
journal = {Proc. ACM Program. Lang.},
month = {Dec},
articleno = {34},
numpages = {29},
keywords = {Iris, semantic soundness, relaxed memory models, Rust}
}

@techreport{cpm,
  author      = " Cuellar, Santiago and Giannarakis, Nick and Madiot, Jean-Marie and Mansky, William and Beringer, Lennart and Cao, Qinxiang and Appel, Andrew ",
  title       = "Compiler Correctness for Concurrency: from concurrent separation logic to shared-memory assembly language",
  institution = "Princeton University",
  year        = "2020"
}

@InProceedings{verifast,
author="Jacobs, Bart
and Smans, Jan
and Philippaerts, Pieter
and Vogels, Fr{\'e}d{\'e}ric
and Penninckx, Willem
and Piessens, Frank",
editor="Bobaru, Mihaela
and Havelund, Klaus
and Holzmann, Gerard J.
and Joshi, Rajeev",
title="{VeriFast}: A Powerful, Sound, Predictable, Fast Verifier for {C} and {Java}",
booktitle="NASA Formal Methods",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="41--55",
abstract="VeriFast is a prototype verification tool for single-threaded and multithreaded C and Java programs. In this paper, we first describe the basic symbolic execution approach in some formal detail. Then we zoom in on two technical aspects: the approach to permission accounting, including fractional permissions, precise predicates, and counting permissions; and the approach to lemma function termination in the presence of dynamically-bound lemma function calls. Finally, we describe three ongoing efforts: application to JavaCard programs, integration of shape analysis, and application to Linux device drivers.",
isbn="978-3-642-20398-5"
}

@article{iris-vst-arxiv,
  doi = {10.48550/ARXIV.2207.06574},
  journal   = {CoRR},
  volume    = {abs/2207.06574},
  url = {https://arxiv.org/abs/2207.06574},
  author = {Mansky, William},
  keywords = {Programming Languages (cs.PL), FOS: Computer and information sciences, FOS: Computer and information sciences, F.3.1},
  title = {Bringing {Iris} into the {Verified Software Toolchain}},
  publisher = {arXiv},
  year = {2022},
  copyright = {Creative Commons Attribution Non Commercial Share Alike 4.0 International}
}

@phdthesis{krishna2019compositional,
  title={Compositional Abstractions for Verifying Concurrent Data Structures},
  author={Krishna, Siddharth},
  year={2019},
  school={New York University}
}

@inproceedings{masstree,
author = {Mao, Yandong and Kohler, Eddie and Morris, Robert Tappan},
title = {Cache Craftiness for Fast Multicore Key-Value Storage},
year = {2012},
isbn = {9781450312233},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2168836.2168855},
doi = {10.1145/2168836.2168855},
abstract = {We present Masstree, a fast key-value database designed for SMP machines. Masstree keeps all data in memory. Its main data structure is a trie-like concatenation of B+-trees, each of which handles a fixed-length slice of a variable-length key. This structure effectively handles arbitrary-length possiblybinary keys, including keys with long shared prefixes. +-tree fanout was chosen to minimize total DRAM delay when descending the tree and prefetching each tree node. Lookups use optimistic concurrency control, a read-copy-update-like technique, and do not write shared data structures; updates lock only affected nodes. Logging and checkpointing provide consistency and durability. Though some of these ideas appear elsewhere, Masstree is the first to combine them. We discuss design variants and their consequences.On a 16-core machine, with logging enabled and queries arriving over a network, Masstree executes more than six million simple queries per second. This performance is comparable to that of memcached, a non-persistent hash table server, and higher (often much higher) than that of VoltDB, MongoDB, and Redis.},
booktitle = {Proceedings of the 7th ACM European Conference on Computer Systems},
pages = {183–196},
numpages = {14},
keywords = {persistent, multicore, key-value, in-memory},
location = {Bern, Switzerland},
series = {EuroSys '12}
}

@article{feldman2020proving,
  title={Proving Highly-Concurrent Traversals Correct},
  author={Feldman, Yotam MY and Khyzha, Artem and Enea, Constantin and Morrison, Adam and Nanevski, Aleksandar and Rinetzky, Noam and Shoham, Sharon},
  journal={Proceedings of the ACM on Programming Languages},
  volume={4},
  number={OOPSLA},
  pages={1--29},
  year={2020},
  publisher={ACM New York, NY, USA}
}

@inproceedings{iris-folly,
author = {Vindum, Simon Friis and Frumin, Dan and Birkedal, Lars},
title = {Mechanized Verification of a Fine-Grained Concurrent Queue from Meta's Folly Library},
year = {2022},
isbn = {9781450391825},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3497775.3503689},
doi = {10.1145/3497775.3503689},
abstract = {We present the first formal specification and verification of the fine-grained concurrent multi-producer-multi-consumer queue algorithm from Meta’s C++ library Folly of core infrastructure components. The queue is highly optimized, practical, and used by Meta in production where it scales to thousands of consumer and producer threads. We present an implementation of the algorithm in an ML-like language and formally prove that it is a contextual refinement of a simple coarse-grained queue (a property that implies that the MPMC queue is linearizable). We use the ReLoC relational logic and the Iris program logic to carry out the proof and to mechanize it in the Coq proof assistant. The MPMC queue is implemented using three modules, and our proof is similarly modular. By using ReLoC and Iris’s support for modular reasoning we verify each module in isolation and compose these together. A key challenge of the MPMC queue is that it has a so-called external linearization point, which ReLoC has no support for reasoning about. Thus we extend ReLoC, both on paper and in Coq, with novel support for reasoning about external linearization points.},
booktitle = {Proceedings of the 11th ACM SIGPLAN International Conference on Certified Programs and Proofs},
pages = {100–115},
numpages = {16},
keywords = {Coq, separation logic, concurrent data structures},
location = {Philadelphia, PA, USA},
series = {CPP 2022}
}

@article{linearizability,
    author = {Herlihy, Maurice P. and Wing, Jeannette M.},
    title = {Linearizability: A Correctness Condition for Concurrent Objects},
    year = {1990},
    issue_date = {July 1990},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {12},
    number = {3},
    issn = {0164-0925},
    url = {https://doi.org/10.1145/78969.78972},
    doi = {10.1145/78969.78972},
    abstract = {A concurrent object is a data object shared by concurrent processes. Linearizability is a correctness condition for concurrent objects that exploits the semantics of abstract data types. It permits a high degree of concurrency, yet it permits programmers to specify and reason about concurrent objects using known techniques from the sequential domain. Linearizability provides the illusion that each operation applied by concurrent processes takes effect instantaneously at some point between its invocation and its response, implying that the meaning of a concurrent object's operations can be given by pre- and post-conditions. This paper defines linearizability, compares it to other correctness conditions, presents and demonstrates a method for proving the correctness of implementations, and shows how to reason about concurrent objects, given they are linearizable.},
    journal = {ACM Trans. Program. Lang. Syst.},
    month = {jul},
    pages = {463–492},
    numpages = {30}
    }

@InProceedings{civl,
author="Kragl, Bernhard
and Qadeer, Shaz
and Henzinger, Thomas A.",
editor="Lahiri, Shuvendu K.
and Wang, Chao",
title="Refinement for Structured Concurrent Programs",
booktitle="Computer Aided Verification",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="275--298",
abstract="This paper presents a foundation for refining concurrent programs with structured control flow. The verification problem is decomposed into subproblems that aid interactive program development, proof reuse, and automation. The formalization in this paper is the basis of a new design and implementation of the Civl verifier.",
isbn="978-3-030-53288-8"
}

@article{template-multi,
author = {Patel, Nisarg and Krishna, Siddharth and Shasha, Dennis and Wies, Thomas},
title = {Verifying Concurrent Multicopy Search Structures},
year = {2021},
issue_date = {October 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {OOPSLA},
url = {https://doi.org/10.1145/3485490},
doi = {10.1145/3485490},
abstract = {Multicopy search structures such as log-structured merge (LSM) trees are optimized for high insert/update/delete (collectively known as upsert) performance. In such data structures, an upsert on key k, which adds (k,v) where v can be a value or a tombstone, is added to the root node even if k is already present in other nodes. Thus there may be multiple copies of k in the search structure. A search on k aims to return the value associated with the most recent upsert. We present a general framework for verifying linearizability of concurrent multicopy search structures that abstracts from the underlying representation of the data structure in memory, enabling proof-reuse across diverse implementations. Based on our framework, we propose template algorithms for (a) LSM structures forming arbitrary directed acyclic graphs and (b) differential file structures, and formally verify these templates in the concurrent separation logic Iris. We also instantiate the LSM template to obtain the first verified concurrent in-memory LSM tree implementation.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {113},
numpages = {32},
keywords = {log-structured merge trees, separation logic, concurrent data structures, template-based verification, flow framework}
}

@InProceedings{grasshopper,
author="Piskac, Ruzica
and Wies, Thomas
and Zufferey, Damien",
editor="{\'A}brah{\'a}m, Erika
and Havelund, Klaus",
title="GRASShopper",
booktitle="Tools and Algorithms for the Construction and Analysis of Systems",
year="2014",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="124--139",
abstract="We present GRASShopper, a tool for compositional verification of heap-manipulating programs against user-provided specifications. What makes our tool unique is its decidable specification language, which supports mixing of assertions expressed in separation logic and first-order logic. The user of the tool can thus take advantage of the succinctness of separation logic specifications and the discipline of local reasoning. Yet, at the same time, she can revert to classical logic in the cases where decidable separation logic fragments are less suited, such as reasoning about constraints on data and heap structures with complex sharing. We achieve this combination of specification languages through a translation to programs whose specifications are expressed in a decidable fragment of first-order logic called GRASS. This logic is well-suited for automation using satisfiability modulo theory solvers. Unlike other tools that provide similar features, our decidability guarantees enable GRASShopper to produce detailed counterexamples for incorrect or underspecified programs.We have found this feature to be invaluable when debugging specifications. We present the underlying philosophy of the tool, describe the major technical challenges, and discuss implementation details. We conclude with an evaluation that considers challenging benchmarks such as sorting algorithms and a union/find data structure.",
isbn="978-3-642-54862-8"
}

@unpublished{bst-conc,
author = {Sharma, Roshan and Wang, Shengyi and Oey, Alexander and Evdokimova, Anastasiia and Beringer, Lennart and Mansky, William},
title = {Proving Logical Atomicity using Lock Invariants},
year = {2022},
note = {Presented at Advances in Separation Logic (ASL 2022)}
}

@software{coq,
  author       = {The Coq Development Team},
  title        = {The Coq Proof Assistant},
  month        = jan,
  year         = 2022,
  publisher    = {Zenodo},
  version      = {8.15},
  doi          = {10.5281/zenodo.5846982},
  url          = {https://doi.org/10.5281/zenodo.5846982}
}

@software{rocq,
  author       = {The Rocq Development Team},
  title        = {The Rocq Prover},
  month        = apr,
  year         = 2025,
  publisher    = {Zenodo},
  version      = {9.0},
  doi          = {10.5281/zenodo.15149629},
  url          = {https://doi.org/10.5281/zenodo.15149629},
}

@inproceedings{wormhole,
  title={Wormhole: A Fast Ordered Index for In-memory Data Management},
  author={Wu, Xingbo and Ni, Fan and Jiang, Song},
  booktitle={Proceedings of the Fourteenth EuroSys Conference 2019},
  pages={1--16},
  year={2019}, 
  doi = {10.1145/3302424.3303955},
}

@article{la-lin,
author = {Birkedal, Lars and Dinsdale-Young, Thomas and Gu\'{e}neau, Arma\"{e}l and Jaber, Guilhem and Svendsen, Kasper and Tzevelekos, Nikos},
title = {Theorems for Free from Separation Logic Specifications},
year = {2021},
issue_date = {August 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {ICFP},
url = {https://doi.org/10.1145/3473586},
doi = {10.1145/3473586},
abstract = {Separation logic specifications with abstract predicates intuitively enforce a discipline that constrains when and how calls may be made between a client and a library. Thus a separation logic specification of a library intuitively enforces a protocol on the trace of interactions between a client and the library. We show how to formalize this intuition and demonstrate how to derive "free theorems" about such interaction traces from abstract separation logic specifications. We present several examples of free theorems. In particular, we prove that a so-called logically atomic concurrent separation logic specification of a concurrent module operation implies that the operation is linearizable. All the results presented in this paper have been mechanized and formally proved in the Coq proof assistant using the Iris higher-order concurrent separation logic framework.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {81},
numpages = {29},
keywords = {Linearizability, Iris, Separation Logic, Program Specifications}
}

@inproceedings{compass,
author = {Dang, Hoang-Hai and Jung, Jaehwang and Choi, Jaemin and Nguyen, Duc-Than and Mansky, William and Kang, Jeehoon and Dreyer, Derek},
title = {Compass: Strong and Compositional Library Specifications in Relaxed Memory Separation Logic},
year = {2022},
isbn = {9781450392655},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3519939.3523451},
doi = {10.1145/3519939.3523451},
abstract = {Several functional correctness criteria have been proposed for relaxed-memory consistency libraries, but most lack support for modular client reasoning. M\'{e}vel and Jourdan recently showed that logical atomicity can be used to give strong modular Hoare-style specifications for relaxed libraries, but only for a limited instance in the Multicore OCaml memory model. It has remained unclear if their approach scales to weaker implementations in weaker memory models. In this work, we combine logical atomicity together with richer partial orders (inspired by prior relaxed-memory correctness criteria) to develop stronger specifications in the weaker memory model of Repaired C11 (RC11). We show their applicability by proving them for multiple implementations of stacks, queues, and exchangers, and we demonstrate their strength by performing multiple client verifications on top of them. Our proofs are mechanized in Compass, a new framework extending the iRC11 separation logic, built atop Iris, in Coq. We report the first mechanized verifications of relaxed-memory implementations for the exchanger, the elimination stack, and the Herlihy-Wing queue.},
booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {792–808},
numpages = {17},
keywords = {C11, linearizability, Iris, relaxed memory models, separation logics, logical atomicity},
location = {San Diego, CA, USA},
series = {PLDI 2022}
}

@article{shasha1988concurrent,
  title={Concurrent Search Structure algorithms},
  author={Shasha, Dennis and Goodman, Nathan},
  journal={ACM Transactions on Database Systems (TODS)},
  volume={13},
  number={1},
  pages={53--90},
  year={1988},
  publisher={ACM New York, NY, USA}
}

@misc{templates-artifact,
  author       = {Nguyen, Duc-Than and
                  Beringer, Lennart and
                  Mansky, William and
                  Wang, Shengyi},
  title        = {{Compositional Verification of Concurrent C 
                   Programs with Search Structure Templates
                   (Artifact)}},
  month        = sep,
  year         = 2023,
  publisher    = {Zenodo},
  doi          = {10.5281/zenodo.8337004},
  url          = {https://doi.org/10.5281/zenodo.8337004}
}

@inproceedings{vst-templates,
author = {Nguyen, Duc-Than and Beringer, Lennart and Mansky, William and Wang, Shengyi},
title = {Compositional Verification of Concurrent C Programs with Search Structure Templates},
year = {2024},
isbn = {9798400704888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3636501.3636940},
doi = {10.1145/3636501.3636940},
abstract = {Concurrent search structure templates are a technique for separating the verification of a concurrent data structure into concurrency-control and data-structure components, which can then be modularly combined with no additional proof effort. In this paper, we implement the template approach in the Verified Software Toolchain (VST), and use it to prove correctness of C implementations of fine-grained concurrent data structures. This involves translating code, specifications, and proofs to the idiom of C and VST, and gives us another look at the requirements and limitations of the template approach.  
We encounter several questions about the boundaries between template and data structure, as well as some common data structure operations that cannot naturally be decomposed into templates. Nonetheless, the approach appears promising for modular verification of real-world concurrent data structures.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Conference on Certified Programs and Proofs},
pages = {60–74},
numpages = {15},
keywords = {logical atomicity, interactive theorem proving, fine-grained locking, concurrent separation logic, Verified Software Toolchain, Iris},
location = {London, UK},
series = {CPP 2024}
}